{
  "id": "doc_020",
  "title": "Principal component analysis",
  "url": "https://en.wikipedia.org/wiki/Principal_component_analysis",
  "topic": "Principal component analysis",
  "content": "Principal component analysis (PCA) is a linear dimensionality reduction technique with applications in exploratory data analysis, visualization and data preprocessing.\nThe data are linearly transformed onto a new coordinate system such that the directions (principal components) capturing the largest variation in the data can be easily identified.\nThe principal components of a collection of points in a real coordinate space are a sequence of \n  \n    \n      \n        p\n      \n    \n    {\\displaystyle p}\n  \n unit vectors, where the \n  \n    \n      \n        i\n      \n    \n    {\\displaystyle i}\n  \n-th vector is the direction of a line that best fits the data while being orthogonal to the first \n  \n    \n      \n        i\n        −\n        1\n      \n    \n    {\\displaystyle i-1}\n  \n vectors. Here, a best-fitting line is defined as one that minimizes the average squared perpendicular distance from the points to the line. These directions (i.e., principal components) constitute an orthonormal basis in which different individual dimensions of the data are linearly uncorrelated. Many studies use the first two principal components in order to plot the data in two dimensions and to visually identify clusters of closely related data points.\nPrincipal component analysis has applications in many fields such as population genetics, microbiome studies, and atmospheric science.\n\n\n== Overview ==\nWhen performing PCA, the first principal component of a set of \n  \n    \n      \n        p\n      \n    \n    {\\displaystyle p}\n  \n variables is the derived variable formed as a linear combination of the original variables that explains the most variance. The second principal component explains the most variance in what is left once the effect of the first component is removed, and we may proceed through \n  \n    \n      \n        p\n      \n    \n    {\\displaystyle p}\n  \n iterations until all the variance is explained. PCA is most commonly used when many of the variables are highly correlated with each other and it is desirable to reduce their number to an independent set.\nThe first principal component can equivalently be defined as a direction that maximizes the variance of the projected data. The \n  \n    \n      \n        i\n      \n    \n    {\\displaystyle i}\n  \n-th principal component can be taken as a direction orthogonal to the first \n  \n    \n      \n        i\n        −\n        1\n      \n    \n    {\\displaystyle i-1}\n  \n principal components that maximizes the variance of the projected data.\nFor either objective, it can be shown that the principal components are eigenvectors of the data's covariance matrix. Thus, the principal components are often computed by eigendecomposition of the data covariance matrix or singular value decomposition of the data matrix. PCA is the simplest of the true eigenvector-based multivariate analyses and is closely related to factor analysis. Factor analysis typically incorporates more domain-specific assumptions about the underlying structure and solves eigenvectors of a slightly different matrix. PCA is also related to canonical correlation analysis (CCA). CCA defines coordinate systems that optimally describe the cross-covariance between two datasets while PCA defines a new orthogonal coordinate system that optimally describes variance in a single dataset. Robust and L1-norm-based variants of standard PCA have also been proposed.\n\n\n== History ==\nPCA was invented in 1901 by Karl Pearson, as an analogue of the principal axis theorem in mechanics; it was later independently developed and named by Harold Hotelling in the 1930s. Depending on the field of application, it is also named the discrete Karhunen–Loève transform (KLT) in signal processing, the Hotelling transform in multivariate quality control, proper orthogonal decomposition (POD) in mechanical engineering, singular value decomposition (SVD) of X (invented in the last quarter of the 19th century), eigenvalue decomposition (EVD) of XTX in linear algebra, factor analysis (for a discussion of the differences between PCA and factor analysis see Ch. 7 of Jolliffe's Principal Component Analysis), Eckart–Young theorem (Harman, 1960), or empirical orthogonal functions (EOF) in meteorological science (Lorenz, 1956), empirical eigenfunction decomposition (Sirovich, 1987), quasiharmonic modes (Brooks et al., 1988), spectral decomposition in noise and vibration, and empirical modal analysis in structural dynamics.\n\n\n== Intuition ==\n\nPCA can be thought of as fitting a p-dimensional ellipsoid to the data, where each axis of the ellipsoid represents a principal component. If some axis of the ellipsoid is small, then the variance along that axis is also small.\nTo find the axes of the ellipsoid, we must first center the values of each variable in the dataset on 0 by subtracting the mean of the variable's observed values from each of those values. These transformed values are used instead of the original observed values for each of the variables. Then, we compute the covariance matrix of the data and calculate the eigenvalues and corresponding eigenvectors of this covariance matrix. Then we must normalize each of the orthogonal eigenvectors to turn them into unit vectors. Once this is done, each of the mutually-orthogonal unit eigenvectors can be interpreted as an axis of the ellipsoid fitted to the data. This choice of basis will transform the covariance matrix into a diagonalized form, in which the diagonal elements represent the variance of each axis. The proportion of the variance that each eigenvector represents can be calculated by dividing the eigenvalue corresponding to that eigenvector by the sum of all eigenvalues.\nBiplots and scree plots (degree of explained variance) are used to interpret findings of the PCA.\n\n\n== Details ==\nPCA is defined as an orthogonal linear transformation on a real inner product space that transforms the data to a new coordinate system such that the greatest variance by some scalar projection of the data comes to lie on the first coordinate (called the first principal component), the second greatest variance on the second coordinate, and so on.\nConsider an \n  \n    \n      \n        n\n        ×\n        p\n      \n    \n    {\\displaystyle n\\times p}\n  \n data matrix, X, with column-wise zero empirical mean (the sample mean of each column has been shifted to zero), where each of the n rows represents a different repetition of the experiment, and each of the p columns gives a particular kind of feature (say, the results from a particular sensor).\nMathematically, the transformation is defined by a set of size \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n (where \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n is usually selected to be strictly less than \n  \n    \n      \n        p\n      \n    \n    {\\displaystyle p}\n  \n to reduce dimensionality) of \n  \n    \n      \n        p\n      \n    \n    {\\displaystyle p}\n  \n-dimensional vectors of weights or coefficients \n  \n    \n      \n        \n          \n            w\n          \n          \n            (\n            k\n            )\n          \n        \n        =\n        (\n        \n          w\n          \n            1\n          \n        \n        ,\n        …\n        ,\n        \n          w\n          \n            p\n          \n        \n        \n          )\n          \n            (\n            k\n            )\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {w} _{(k)}=(w_{1},\\dots ,w_{p})_{(k)}}\n  \n that map each row vector \n  \n    \n      \n        \n          \n            x\n          \n          \n            (\n            i\n            )\n          \n        \n        =\n        (\n        \n          x\n          \n            1\n          \n        \n        ,\n        …\n        ,\n        \n          x\n          \n            p\n          \n        \n        \n          )\n          \n            (\n            i\n            )\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {x} _{(i)}=(x_{1},\\dots ,x_{p})_{(i)}}\n  \n of X to a new vector of principal component scores \n  \n    \n      \n        \n          \n            t\n          \n          \n            (\n            i\n            )\n          \n        \n        =\n        (\n        \n          t\n          \n            1\n          \n        \n        ,\n        …\n        ,\n        \n          t\n          \n            l\n          \n        \n        \n          )\n          \n            (\n            i\n            )\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {t} _{(i)}=(t_{1},\\dots ,t_{l})_{(i)}}\n  \n, given by\n\n  \n    \n      \n        \n          \n            \n              t\n              \n                k\n              \n            \n          \n          \n            (\n            i\n            )\n          \n        \n        =\n        \n          \n            x\n          \n          \n            (\n            i\n            )\n          \n        \n        ⋅\n        \n          \n            w\n          \n          \n            (\n            k\n            )\n          \n        \n        \n        \n          f\n          o\n          r\n        \n        \n        i\n        =\n        1\n        ,\n        …\n        ,\n        n\n        \n        k\n        =\n        1\n        ,\n        …\n        ,\n        l\n      \n    \n    {\\displaystyle {t_{k}}_{(i)}=\\mathbf {x} _{(i)}\\cdot \\mathbf {w} _{(k)}\\qquad \\mathrm {for} \\qquad i=1,\\dots ,n\\qquad k=1,\\dots ,l}\n  \n\nin such a way that the individual variables \n  \n    \n      \n        \n          t\n          \n            1\n          \n        \n        ,\n        …\n        ,\n        \n          t\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle t_{1},\\dots ,t_{l}}\n  \n of t considered over the data set successively inherit the maximum possible variance from X, with each coefficient vector w constrained to be a unit vector.\nThe above may equivalently be written in matrix form as \n\n  \n    \n      \n        \n          T\n        \n        =\n        \n          X\n        \n        \n          W\n        \n      \n    \n    {\\displaystyle \\mathbf {T} =\\mathbf {X} \\mathbf {W} }\n  \n\nwhere\n\n  \n    \n      \n        \n          \n            \n              T\n            \n          \n          \n            i\n            k\n          \n        \n        =\n        \n          \n            \n              t\n              \n                k\n              \n            \n          \n          \n            (\n            i\n            )\n          \n        \n      \n    \n    {\\displaystyle {\\mathbf {T} }_{ik}={t_{k}}_{(i)}}\n  \n,\n\n  \n    \n      \n        \n          \n            \n              X\n            \n          \n          \n            i\n            j\n          \n        \n        =\n        \n          \n            \n              x\n              \n                j\n              \n            \n          \n          \n            (\n            i\n            )\n          \n        \n      \n    \n    {\\displaystyle {\\mathbf {X} }_{ij}={x_{j}}_{(i)}}\n  \n, and\n\n  \n    \n      \n        \n          \n            \n              W\n            \n          \n          \n            j\n            k\n          \n        \n        =\n        \n          \n            \n              w\n              \n                j\n              \n            \n          \n          \n            (\n            k\n            )\n          \n        \n      \n    \n    {\\displaystyle {\\mathbf {W} }_{jk}={w_{j}}_{(k)}}\n  \n.\n\n\n=== First component ===\nIn order to maximize variance, the first weight vector w(1) thus has to satisfy\n\n  \n    \n      \n        \n          \n            w\n          \n          \n            (\n            1\n            )\n          \n        \n        =\n        arg\n        ⁡\n        \n          max\n          \n            ‖\n            \n              w\n            \n            ‖\n            =\n            1\n          \n        \n        \n        \n          {\n          \n            \n              ∑\n              \n                i\n              \n            \n            (\n            \n              t\n              \n                1\n              \n            \n            \n              )\n              \n                (\n                i\n                )\n              \n              \n                2\n              \n            \n          \n          }\n        \n        =\n        arg\n        ⁡\n        \n          max\n          \n            ‖\n            \n              w\n            \n            ‖\n            =\n            1\n          \n        \n        \n        \n          {\n          \n            \n              ∑\n              \n                i\n              \n            \n            \n              \n                (\n                \n                  \n                    \n                      x\n                    \n                    \n                      (\n                      i\n                      )\n                    \n                  \n                  ⋅\n                  \n                    w\n                  \n                \n                )\n              \n              \n                2\n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle \\mathbf {w} _{(1)}=\\arg \\max _{\\Vert \\mathbf {w} \\Vert =1}\\,\\left\\{\\sum _{i}(t_{1})_{(i)}^{2}\\right\\}=\\arg \\max _{\\Vert \\mathbf {w} \\Vert =1}\\,\\left\\{\\sum _{i}\\left(\\mathbf {x} _{(i)}\\cdot \\mathbf {w} \\right)^{2}\\right\\}}\n  \n\nEquivalently, writing this in matrix form gives\n\n  \n    \n      \n        \n          \n            w\n          \n          \n            (\n            1\n            )\n          \n        \n        =\n        arg\n        ⁡\n        \n          max\n          \n            \n              ‖\n              \n                w\n              \n              ‖\n            \n            =\n            1\n          \n        \n        \n          {\n          \n            \n              ‖\n              \n                X\n                w\n              \n              ‖\n            \n            \n              2\n            \n          \n          }\n        \n        =\n        arg\n        ⁡\n        \n          max\n          \n            \n              ‖\n              \n                w\n              \n              ‖\n            \n            =\n            1\n          \n        \n        \n          {\n          \n            \n              \n                w\n              \n              \n                \n                  T\n                \n              \n            \n            \n              \n                X\n              \n              \n                \n                  T\n                \n              \n            \n            \n              X\n              w\n            \n          \n          }\n        \n      \n    \n    {\\displaystyle \\mathbf {w} _{(1)}=\\arg \\max _{\\left\\|\\mathbf {w} \\right\\|=1}\\left\\{\\left\\|\\mathbf {Xw} \\right\\|^{2}\\right\\}=\\arg \\max _{\\left\\|\\mathbf {w} \\right\\|=1}\\left\\{\\mathbf {w} ^{\\mathsf {T}}\\mathbf {X} ^{\\mathsf {T}}\\mathbf {Xw} \\right\\}}\n  \n\nSince w(1) has been defined to be a unit vector, it equivalently also satisfies\n\n  \n    \n      \n        \n          \n            w\n          \n          \n            (\n            1\n            )\n          \n        \n        =\n        arg\n        ⁡\n        max\n        \n          {\n          \n            \n              \n                \n                  \n                    w\n                  \n                  \n                    \n                      T\n                    \n                  \n                \n                \n                  \n                    X\n                  \n                  \n                    \n                      T\n                    \n                  \n                \n                \n                  X\n                  w\n                \n              \n              \n                \n                  \n                    w\n                  \n                  \n                    \n                      T\n                    \n                  \n                \n                \n                  w\n                \n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle \\mathbf {w} _{(1)}=\\arg \\max \\left\\{{\\frac {\\mathbf {w} ^{\\mathsf {T}}\\mathbf {X} ^{\\mathsf {T}}\\mathbf {Xw} }{\\mathbf {w} ^{\\mathsf {T}}\\mathbf {w} }}\\right\\}}\n  \n\nThe quantity to be maximised can be recognised as a Rayleigh quotient. A standard result for a positive semidefinite matrix such as XTX is that the quotient's maximum possible value is the largest eigenvalue of the matrix, which occurs when w is the corresponding eigenvector.\nWith w(1) found, the first principal component of a data vector x(i) can then be given as a score t1(i) = x(i) ⋅ w(1) in the transformed co-ordinates, or as the corresponding vector in the original variables, {x(i) ⋅ w(1)} w(1).\n\n\n=== Further components ===\nThe k-th component can be found by subtracting the first k − 1 principal components from X:\n\n  \n    \n      \n        \n          \n            \n              \n                X\n                ^\n              \n            \n          \n          \n            k\n          \n        \n        =\n        \n          X\n        \n        −\n        \n          ∑\n          \n            s\n            =\n            1\n          \n          \n            k\n            −\n            1\n          \n        \n        \n          X\n        \n        \n          \n            w\n          \n          \n            (\n            s\n            )\n          \n        \n        \n          \n            w\n          \n          \n            (\n            s\n            )\n          \n          \n            \n              T\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {\\hat {X}} _{k}=\\mathbf {X} -\\sum _{s=1}^{k-1}\\mathbf {X} \\mathbf {w} _{(s)}\\mathbf {w} _{(s)}^{\\mathsf {T}}}\n  \n\nand then finding the weight vector which extracts the maximum variance from this new data matrix\n\n  \n    \n      \n        \n          \n            w\n          \n          \n            (\n            k\n            )\n          \n        \n        =\n        \n          \n            \n              a\n              r\n              g\n              \n              m\n              a\n              x\n            \n          \n          \n            \n              ‖\n              \n                w\n              \n              ‖\n            \n            =\n            1\n          \n        \n        ⁡\n        \n          {\n          \n            \n              ‖\n              \n                \n                  \n                    \n                      \n                        X\n                        ^\n                      \n                    \n                  \n                  \n                    k\n                  \n                \n                \n                  w\n                \n              \n              ‖\n            \n            \n              2\n            \n          \n          }\n        \n        =\n        arg\n        ⁡\n        max\n        \n          {\n          \n            \n              \n                \n                  \n                    \n                      w\n                    \n                    \n                      \n                        T\n                      \n                    \n                  \n                  \n                    \n                      \n                        \n                          X\n                          ^\n                        \n                      \n                    \n                    \n                      k\n                    \n                    \n                      \n                        T\n                      \n                    \n                  \n                  \n                    \n                      \n                        \n                          X\n                          ^\n                        \n                      \n                    \n                    \n                      k\n                    \n                  \n                  \n                    w\n                  \n                \n                \n                  \n                    \n                      w\n                    \n                    \n                      T\n                    \n                  \n                  \n                    w\n                  \n                \n              \n            \n          \n          }\n        \n      \n    \n    {\\displaystyle \\mathbf {w} _{(k)}=\\mathop {\\operatorname {arg\\,max} } _{\\left\\|\\mathbf {w} \\right\\|=1}\\left\\{\\left\\|\\mathbf {\\hat {X}} _{k}\\mathbf {w} \\right\\|^{2}\\right\\}=\\arg \\max \\left\\{{\\tfrac {\\mathbf {w} ^{\\mathsf {T}}\\mathbf {\\hat {X}} _{k}^{\\mathsf {T}}\\mathbf {\\hat {X}} _{k}\\mathbf {w} }{\\mathbf {w} ^{T}\\mathbf {w} }}\\right\\}}\n  \n\nIt turns out that this gives the remaining eigenvectors of XTX, with the maximum values for the quantity in brackets given by their corresponding eigenvalues. Thus the weight vectors are eigenvectors of XTX.\nThe k-th principal component of a data vector x(i) can therefore be given as a score tk(i) = x(i) ⋅ w(k) in the transformed coordinates, or as the corresponding vector in the space of the original variables, {x(i) ⋅ w(k)} w(k), where w(k) is the kth eigenvector of XTX.\nThe full principal components decomposition of X can therefore be given as\n\n  \n    \n      \n        \n          T\n        \n        =\n        \n          X\n        \n        \n          W\n        \n      \n    \n    {\\displaystyle \\mathbf {T} =\\mathbf {X} \\mathbf {W} }\n  \n\nwhere W is a p-by-p matrix of weights whose columns are the eigenvectors of XTX. The transpose of W is sometimes called the whitening or sphering transformation. Columns of W multiplied by the square root of corresponding eigenvalues, that is, eigenvectors scaled up by the variances, are called loadings in PCA or in Factor analysis.\n\n\n=== Covariances ===\nXTX itself can be recognized as proportional to the empirical sample covariance matrix of the dataset XT.\nThe sample covariance Q between two of the different principal components over the dataset is given by:\n\n  \n    \n      \n        \n          \n            \n              \n                Q\n                (\n                \n                  \n                    P\n                    C\n                  \n                  \n                    (\n                    j\n                    )\n                  \n                \n                ,\n                \n                  \n                    P\n                    C\n                  \n                  \n                    (\n                    k\n                    )\n                  \n                \n                )\n              \n              \n                \n                ∝\n                (\n                \n                  X\n                \n                \n                  \n                    w\n                  \n                  \n                    (\n                    j\n                    )\n                  \n                \n                \n                  )\n                  \n                    \n                      T\n                    \n                  \n                \n                (\n                \n                  X\n                \n                \n                  \n                    w\n                  \n                  \n                    (\n                    k\n                    )\n                  \n                \n                )\n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    w\n                  \n                  \n                    (\n                    j\n                    )\n                  \n                  \n                    \n                      T\n                    \n                  \n                \n                \n                  \n                    X\n                  \n                  \n                    \n                      T\n                    \n                  \n                \n                \n                  X\n                \n                \n                  \n                    w\n                  \n                  \n                    (\n                    k\n                    )\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  \n                    w\n                  \n                  \n                    (\n                    j\n                    )\n                  \n                  \n                    \n                      T\n                    \n                  \n                \n                \n                  λ\n                  \n                    (\n                    k\n                    )\n                  \n                \n                \n                  \n                    w\n                  \n                  \n                    (\n                    k\n                    )\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  λ\n                  \n                    (\n                    k\n                    )\n                  \n                \n                \n                  \n                    w\n                  \n                  \n                    (\n                    j\n                    )\n                  \n                  \n                    \n                      T\n                    \n                  \n                \n                \n                  \n                    w\n                  \n                  \n                    (\n                    k\n                    )\n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}Q(\\mathrm {PC} _{(j)},\\mathrm {PC} _{(k)})&\\propto (\\mathbf {X} \\mathbf {w} _{(j)})^{\\mathsf {T}}(\\mathbf {X} \\mathbf {w} _{(k)})\\\\&=\\mathbf {w} _{(j)}^{\\mathsf {T}}\\mathbf {X} ^{\\mathsf {T}}\\mathbf {X} \\mathbf {w} _{(k)}\\\\&=\\mathbf {w} _{(j)}^{\\mathsf {T}}\\lambda _{(k)}\\mathbf {w} _{(k)}\\\\&=\\lambda _{(k)}\\mathbf {w} _{(j)}^{\\mathsf {T}}\\mathbf {w} _{(k)}\\end{aligned}}}\n  \n\nwhere the eigenvalue property of w(k) has been used to move from line 2 to line 3. However eigenvectors w(j) and w(k) corresponding to eigenvalues of a symmetric matrix are orthogonal (if the eigenvalues are different), or can be orthogonalised (if the vectors happen to share an equal repeated value). The product in the final line is therefore zero; there is no sample covariance between different principal components over the dataset.\nAnother way to characterise the principal components transformation is therefore as the transformation to coordinates which diagonalise the empirical sample covariance matrix.\nIn matrix form, the empirical covariance matrix for the original variables can be written\n\n  \n    \n      \n        \n          Q\n        \n        ∝\n        \n          \n            X\n          \n          \n            \n              T\n            \n          \n        \n        \n          X\n        \n        =\n        \n          W\n        \n        \n          Λ\n        \n        \n          \n            W\n          \n          \n            \n              T\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {Q} \\propto \\mathbf {X} ^{\\mathsf {T}}\\mathbf {X} =\\mathbf {W} \\mathbf {\\Lambda } \\mathbf {W} ^{\\mathsf {T}}}\n  \n\nThe empirical covariance matrix between the principal components becomes\n\n  \n    \n      \n        \n          \n            W\n          \n          \n            \n              T\n            \n          \n        \n        \n          Q\n        \n        \n          W\n        \n        ∝\n        \n          \n            W\n          \n          \n            \n              T\n            \n          \n        \n        \n          W\n        \n        \n        \n          Λ\n        \n        \n        \n          \n            W\n          \n          \n            \n              T\n            \n          \n        \n        \n          W\n        \n        =\n        \n          Λ\n        \n      \n    \n    {\\displaystyle \\mathbf {W} ^{\\mathsf {T}}\\mathbf {Q} \\mathbf {W} \\propto \\mathbf {W} ^{\\mathsf {T}}\\mathbf {W} \\,\\mathbf {\\Lambda } \\,\\mathbf {W} ^{\\mathsf {T}}\\mathbf {W} =\\mathbf {\\Lambda } }\n  \n\nwhere Λ is the diagonal matrix of eigenvalues λ(k) of XTX. λ(k) is equal to the sum of the squares over the dataset associated with each component k, that is, λ(k) = Σi tk2(i) = Σi (x(i) ⋅ w(k))2.\n\n\n=== Dimensionality reduction ===\nThe transformation P = X W maps a data vector x(i) from an original space of x variables to a new space of p variables which are uncorrelated over the dataset.\nTo non-dimensionalize the centered data, let Xc represent the characteristic values of data vectors Xi, given by:\n\n  \n    \n      \n        ‖\n        X\n        \n          ‖\n          \n            ∞\n          \n        \n      \n    \n    {\\displaystyle \\|X\\|_{\\infty }}\n  \n (maximum norm),\n\n  \n    \n      \n        \n          \n            1\n            n\n          \n        \n        ‖\n        X\n        \n          ‖\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle {\\frac {1}{n}}\\|X\\|_{1}}\n  \n (mean absolute value), or\n\n  \n    \n      \n        \n          \n            1\n            \n              n\n            \n          \n        \n        ‖\n        X\n        \n          ‖\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle {\\frac {1}{\\sqrt {n}}}\\|X\\|_{2}}\n  \n (normalized Euclidean norm),\nfor a dataset of size n. These norms are used to transform the original space of variables x, y to a new space of uncorrelated variables p, q (given Yc with same meaning), such that \n  \n    \n      \n        \n          p\n          \n            i\n          \n        \n        =\n        \n          \n            \n              X\n              \n                i\n              \n            \n            \n              X\n              \n                c\n              \n            \n          \n        \n        ,\n        \n        \n          q\n          \n            i\n          \n        \n        =\n        \n          \n            \n              Y\n              \n                i\n              \n            \n            \n              Y\n              \n                c\n              \n            \n          \n        \n      \n    \n    {\\displaystyle p_{i}={\\frac {X_{i}}{X_{c}}},\\quad q_{i}={\\frac {Y_{i}}{Y_{c}}}}\n  \n;\nand the new variables are linearly related as: \n  \n    \n      \n        q\n        =\n        α\n        p\n      \n    \n    {\\displaystyle q=\\alpha p}\n  \n.\nTo find the optimal linear relationship, we minimize the total squared reconstruction error:\n\n  \n    \n      \n        E\n        (\n        α\n        )\n        =\n        \n          \n            1\n            \n              1\n              −\n              \n                α\n                \n                  2\n                \n              \n            \n          \n        \n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            n\n          \n        \n        (\n        α\n        \n          p\n          \n            i\n          \n        \n        −\n        \n          q\n          \n            i\n          \n        \n        \n          )\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle E(\\alpha )={\\frac {1}{1-\\alpha ^{2}}}\\sum _{i=1}^{n}(\\alpha p_{i}-q_{i})^{2}}\n  \n; such that setting the derivative of the error function to zero \n  \n    \n      \n        (\n        \n          E\n          ′\n        \n        (\n        α\n        )\n        =\n        0\n        )\n      \n    \n    {\\displaystyle (E'(\\alpha )=0)}\n  \n yields:\n  \n    \n      \n        α\n        =\n        \n          \n            1\n            2\n          \n        \n        \n          (\n          \n            −\n            λ\n            ±\n            \n              \n                \n                  λ\n                  \n                    2\n                  \n                \n                +\n                4\n              \n            \n          \n          )\n        \n      \n    \n    {\\displaystyle \\alpha ={\\frac {1}{2}}\\left(-\\lambda \\pm {\\sqrt {\\lambda ^{2}+4}}\\right)}\n  \n where\n  \n    \n      \n        λ\n        =\n        \n          \n            \n              p\n              ⋅\n              p\n              −\n              q\n              ⋅\n              q\n            \n            \n              p\n              ⋅\n              q\n            \n          \n        \n      \n    \n    {\\displaystyle \\lambda ={\\frac {p\\cdot p-q\\cdot q}{p\\cdot q}}}\n  \n.\n\nSuch dimensionality reduction can be a very useful step for visualising and processing high-dimensional datasets, while still retaining as much of the variance in the dataset as possible. For example, selecting L = 2 and keeping only the first two principal components finds the two-dimensional plane through the high-dimensional dataset in which the data are most spread out, so if the data contains clusters these too may be most spread out, and therefore most visible to be plotted out in a two-dimensional diagram; whereas if two directions through the data (or two of the original variables) are chosen at random, the clusters may be much less spread apart from each other, and may in fact be much more likely to substantially overlay each other, making them indistinguishable.\nSimilarly, in regression analysis, the larger the number of explanatory variables allowed, the greater is the chance of overfitting the model, producing conclusions that fail to generalise to other datasets. One approach, especially when there are strong correlations between different possible explanatory variables, is to reduce them to a few principal components and then run the regression against them, a method called principal component regression.\nDimensionality reduction may also be appropriate when the variables in a dataset are noisy. If each column of the dataset contains independent identically distributed Gaussian noise, then the columns of T will also contain similarly identically distributed Gaussian noise (such a distribution is invariant under the effects of the matrix W, which can be thought of as a high-dimensional rotation of the co-ordinate axes). However, with more of the total variance concentrated in the first few principal components compared to the same noise variance, the proportionate effect of the noise is less—the first few components achieve a higher signal-to-noise ratio. PCA thus can have the effect of concentrating much of the signal into the first few principal components, which can usefully be captured by dimensionality reduction; while the later principal components may be dominated by noise, and so disposed of without great loss. If the dataset is not too large, the significance of the principal components can be tested using parametric bootstrap, as an aid in determining how many principal components to retain.\n\n\n=== Singular value decomposition ===\n\nThe principal components transformation can also be associated with another matrix factorization, the singular value decomposition (SVD) of X,\n\n  \n    \n      \n        \n          X\n        \n        =\n        \n          U\n        \n        \n          Σ\n        \n        \n          \n            W\n          \n          \n            T\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {X} =\\mathbf {U} \\mathbf {\\Sigma } \\mathbf {W} ^{T}}\n  \n\nHere Σ is an n-by-p rectangular diagonal matrix of positive numbers σ(k), called the singular values of X; U is an n-by-n matrix, the columns of which are orthogonal unit vectors of length n called the left singular vectors of X; and W is a p-by-p matrix whose columns are orthogonal unit vectors of length p and called the right singular vectors of X.\nIn terms of this factorization, the matrix XTX can be written\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  \n                    X\n                  \n                  \n                    T\n                  \n                \n                \n                  X\n                \n              \n              \n                \n                =\n                \n                  W\n                \n                \n                  \n                    Σ\n                  \n                  \n                    \n                      T\n                    \n                  \n                \n                \n                  \n                    U\n                  \n                  \n                    \n                      T\n                    \n                  \n                \n                \n                  U\n                \n                \n                  Σ\n                \n                \n                  \n                    W\n                  \n                  \n                    \n                      T\n                    \n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  W\n                \n                \n                  \n                    Σ\n                  \n                  \n                    \n                      T\n                    \n                  \n                \n                \n                  Σ\n                \n                \n                  \n                    W\n                  \n                  \n                    \n                      T\n                    \n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  W\n                \n                \n                  \n                    \n                      \n                        Σ\n                        ^\n                      \n                    \n                  \n                  \n                    2\n                  \n                \n                \n                  \n                    W\n                  \n                  \n                    \n                      T\n                    \n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}\\mathbf {X} ^{T}\\mathbf {X} &=\\mathbf {W} \\mathbf {\\Sigma } ^{\\mathsf {T}}\\mathbf {U} ^{\\mathsf {T}}\\mathbf {U} \\mathbf {\\Sigma } \\mathbf {W} ^{\\mathsf {T}}\\\\&=\\mathbf {W} \\mathbf {\\Sigma } ^{\\mathsf {T}}\\mathbf {\\Sigma } \\mathbf {W} ^{\\mathsf {T}}\\\\&=\\mathbf {W} \\mathbf {\\hat {\\Sigma }} ^{2}\\mathbf {W} ^{\\mathsf {T}}\\end{aligned}}}\n  \n\nwhere  \n  \n    \n      \n        \n          \n            \n              Σ\n              ^\n            \n          \n        \n      \n    \n    {\\displaystyle \\mathbf {\\hat {\\Sigma }} }\n  \n is the square diagonal matrix with the singular values of X and the excess zeros chopped off that satisfies \n  \n    \n      \n        \n          \n            \n              \n                \n                  Σ\n                  ^\n                \n              \n            \n            \n              2\n            \n          \n        \n        =\n        \n          \n            Σ\n          \n          \n            \n              T\n            \n          \n        \n        \n          Σ\n        \n      \n    \n    {\\displaystyle \\mathbf {{\\hat {\\Sigma }}^{2}} =\\mathbf {\\Sigma } ^{\\mathsf {T}}\\mathbf {\\Sigma } }\n  \n. Comparison with the eigenvector factorization of XTX establishes that the right singular vectors W of X are equivalent to the eigenvectors of XTX, while the singular values σ(k) of  \n  \n    \n      \n        \n          X\n        \n      \n    \n    {\\displaystyle \\mathbf {X} }\n  \n are equal to the square-root of the eigenvalues λ(k) of XTX.\nUsing the singular value decomposition the score matrix T can be written\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  T\n                \n              \n              \n                \n                =\n                \n                  X\n                \n                \n                  W\n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  U\n                \n                \n                  Σ\n                \n                \n                  \n                    W\n                  \n                  \n                    \n                      T\n                    \n                  \n                \n                \n                  W\n                \n              \n            \n            \n              \n              \n                \n                =\n                \n                  U\n                \n                \n                  Σ\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}\\mathbf {T} &=\\mathbf {X} \\mathbf {W} \\\\&=\\mathbf {U} \\mathbf {\\Sigma } \\mathbf {W} ^{\\mathsf {T}}\\mathbf {W} \\\\&=\\mathbf {U} \\mathbf {\\Sigma } \\end{aligned}}}\n  \n\nso each column of T is given by one of the left singular vectors of X multiplied by the corresponding singular value. This form is also the polar decomposition of T.\nEfficient algorithms exist to calculate the SVD of X without having to form the matrix XTX, so computing the SVD is now the standard way to calculate a principal components analysis from a data matrix, unless only a handful of components are required.\nAs with the eigen-decomposition, a truncated n × L score matrix TL can be obtained by considering only the first L largest singular values and their singular vectors:\n\n  \n    \n      \n        \n          \n            T\n          \n          \n            L\n          \n        \n        =\n        \n          \n            U\n          \n          \n            L\n          \n        \n        \n          \n            Σ\n          \n          \n            L\n          \n        \n        =\n        \n          X\n        \n        \n          \n            W\n          \n          \n            L\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {T} _{L}=\\mathbf {U} _{L}\\mathbf {\\Sigma } _{L}=\\mathbf {X} \\mathbf {W} _{L}}\n  \n\nThe truncation of a matrix M or T using a truncated singular value decomposition in this way produces a truncated matrix that is the nearest possible matrix of rank L to the original matrix, in the sense of the difference between the two having the smallest possible Frobenius norm, a result known as the Eckart–Young theorem [1936].\n\nTheorem (Optimal k‑dimensional fit).  \nLet P be an n×m data matrix whose columns have been mean‑centered and scaled, and let  \n\n  \n    \n      \n        P\n        =\n        U\n        \n        Σ\n        \n        \n          V\n          \n            T\n          \n        \n      \n    \n    {\\displaystyle P=U\\,\\Sigma \\,V^{T}}\n  \n  \nbe its singular value decomposition. Then the best rank‑k approximation to P in the least‑squares (Frobenius‑norm) sense is  \n\n  \n    \n      \n        \n          P\n          \n            k\n          \n        \n        =\n        \n          U\n          \n            k\n          \n        \n        \n        \n          Σ\n          \n            k\n          \n        \n        \n        \n          V\n          \n            k\n          \n          \n            T\n          \n        \n      \n    \n    {\\displaystyle P_{k}=U_{k}\\,\\Sigma _{k}\\,V_{k}^{T}}\n  \n,  \nwhere Vk consists of the first k columns of V. Moreover, the relative residual variance is  \n\n  \n    \n      \n        R\n        (\n        k\n        )\n        =\n        \n          \n            \n              \n                ∑\n                \n                  j\n                  =\n                  k\n                  +\n                  1\n                \n                \n                  m\n                \n              \n              \n                σ\n                \n                  j\n                \n                \n                  2\n                \n              \n            \n            \n              \n                ∑\n                \n                  j\n                  =\n                  1\n                \n                \n                  m\n                \n              \n              \n                σ\n                \n                  j\n                \n                \n                  2\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle R(k)={\\frac {\\sum _{j=k+1}^{m}\\sigma _{j}^{2}}{\\sum _{j=1}^{m}\\sigma _{j}^{2}}}}\n  \n.\n\n\n== Further considerations ==\nThe singular values (in Σ) are the square roots of the eigenvalues of the matrix XTX. Each eigenvalue is proportional to the portion of the \"variance\" (more correctly of the sum of the squared distances of the points from their multidimensional mean) that is associated with each eigenvector. The sum of all the eigenvalues is equal to the sum of the squared distances of the points from their multidimensional mean. PCA essentially rotates the set of points around their mean in order to align with the principal components. This moves as much of the variance as possible (using an orthogonal transformation) into the first few dimensions. The values in the remaining dimensions, therefore, tend to be small and may be dropped with minimal loss of information (see below). PCA is often used in this manner for dimensionality reduction. PCA has the distinction of being the optimal orthogonal transformation for keeping the subspace that has largest \"variance\" (as defined above). This advantage, however, comes at the price of greater computational requirements if compared, for example, and when applicable, to the discrete cosine transform, and in particular to the DCT-II which is simply known as the \"DCT\". Nonlinear dimensionality reduction techniques tend to be more computationally demanding than PCA.\nPCA is sensitive to the scaling of the variables. Mathematically this sensitivity comes from the way a rescaling changes the sample‑covariance matrix that PCA diagonalises.\nLet \n  \n    \n      \n        \n          \n            X\n          \n          \n            c\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {X} _{\\text{c}}}\n  \n be the *centered* data matrix (n rows, p columns) and define the covariance\n\n  \n    \n      \n        Σ\n        =\n        \n          \n            1\n            n\n          \n        \n        \n        \n          \n            X\n          \n          \n            c\n          \n          \n            \n              T\n            \n          \n        \n        \n          \n            X\n          \n          \n            c\n          \n        \n        .\n      \n    \n    {\\displaystyle \\Sigma ={\\frac {1}{n}}\\,\\mathbf {X} _{\\text{c}}^{\\mathsf {T}}\\mathbf {X} _{\\text{c}}.}\n  \n\nIf the \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n‑th variable is multiplied by a factor \n  \n    \n      \n        \n          α\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle \\alpha _{j}}\n  \n we obtain  \n\n  \n    \n      \n        \n          \n            X\n          \n          \n            c\n          \n          \n            (\n            α\n            )\n          \n        \n        =\n        \n          \n            X\n          \n          \n            c\n          \n        \n        D\n        ,\n        \n        D\n        =\n        diag\n        ⁡\n        (\n        \n          α\n          \n            1\n          \n        \n        ,\n        …\n        ,\n        \n          α\n          \n            p\n          \n        \n        )\n        .\n      \n    \n    {\\displaystyle \\mathbf {X} _{\\text{c}}^{(\\alpha )}=\\mathbf {X} _{\\text{c}}D,\\qquad D=\\operatorname {diag} (\\alpha _{1},\\ldots ,\\alpha _{p}).}\n  \n  \nHence the new covariance is  \n\n  \n    \n      \n        \n          Σ\n          \n            (\n            α\n            )\n          \n        \n        =\n        \n          D\n          \n            \n              T\n            \n          \n        \n        \n        Σ\n        \n        D\n        .\n      \n    \n    {\\displaystyle \\Sigma ^{(\\alpha )}=D^{\\mathsf {T}}\\,\\Sigma \\,D.}\n  \n\nBecause the eigenvalues and eigenvectors of \n  \n    \n      \n        \n          Σ\n          \n            (\n            α\n            )\n          \n        \n      \n    \n    {\\displaystyle \\Sigma ^{(\\alpha )}}\n  \n are those of \n  \n    \n      \n        Σ\n      \n    \n    {\\displaystyle \\Sigma }\n  \n scaled by \n  \n    \n      \n        D\n      \n    \n    {\\displaystyle D}\n  \n, the principal axes rotate toward any column whose variance has been inflated, exactly as the 2‑D example below illustrates.\nIf we have just two variables and they have the same sample variance and are completely correlated, then the PCA will entail a rotation by 45° and the \"weights\" (they are the cosines of rotation) for the two variables with respect to the principal component will be equal. But if we multiply all values of the first variable by 100, then the first principal component will be almost the same as that variable, with a small contribution from the other variable, whereas the second component will be almost aligned with the second original variable. This means that whenever the different variables have different units (like temperature and mass), PCA is a somewhat arbitrary method of analysis. (Different results would be obtained if one used Fahrenheit rather than Celsius for example.) Pearson's original paper was entitled \"On Lines and Planes of Closest Fit to Systems of Points in Space\" – \"in space\" implies physical Euclidean space where such concerns do not arise. One way of making the PCA less arbitrary is to use variables scaled so as to have unit variance, by standardizing the data and hence use the autocorrelation matrix instead of the autocovariance matrix as a basis for PCA. However, this compresses (or expands) the fluctuations in all dimensions of the signal space to unit variance.\nClassical PCA assumes the cloud of points has already been translated so its centroid is at the origin.\nWrite each observation as  \n\n  \n    \n      \n        \n          \n            q\n          \n          \n            i\n          \n        \n        =\n        \n          μ\n        \n        +\n        \n          \n            z\n          \n          \n            i\n          \n        \n        ,\n        \n        \n          μ\n        \n        =\n        \n          \n            \n              1\n              n\n            \n          \n        \n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          \n            q\n          \n          \n            i\n          \n        \n        .\n      \n    \n    {\\displaystyle \\mathbf {q} _{i}={\\boldsymbol {\\mu }}+\\mathbf {z} _{i},\\qquad {\\boldsymbol {\\mu }}={\\tfrac {1}{n}}\\sum _{i=1}^{n}\\mathbf {q} _{i}.}\n  \n\nWithout subtracting \n  \n    \n      \n        \n          μ\n        \n      \n    \n    {\\displaystyle {\\boldsymbol {\\mu }}}\n  \n we are in effect diagonalising\n\n  \n    \n      \n        \n          Σ\n          \n            unc\n          \n        \n        \n        =\n        \n        n\n        \n        \n          μ\n        \n        \n          \n            μ\n          \n          \n            \n              T\n            \n          \n        \n        \n        +\n        \n        \n          \n            \n              1\n              n\n            \n          \n        \n        \n        \n          \n            Z\n          \n          \n            \n              T\n            \n          \n        \n        \n          Z\n        \n        ,\n      \n    \n    {\\displaystyle \\Sigma _{\\text{unc}}\\;=\\;n\\,{\\boldsymbol {\\mu }}{\\boldsymbol {\\mu }}^{\\mathsf {T}}\\;+\\;{\\tfrac {1}{n}}\\,\\mathbf {Z} ^{\\mathsf {T}}\\mathbf {Z} ,}\n  \n\nwhere \n  \n    \n      \n        \n          Z\n        \n      \n    \n    {\\displaystyle \\mathbf {Z} }\n  \n is the centered matrix.  \nThe rank‑one term \n  \n    \n      \n        n\n        \n        \n          μ\n        \n        \n          \n            μ\n          \n          \n            \n              T\n            \n          \n        \n      \n    \n    {\\displaystyle n\\,{\\boldsymbol {\\mu }}{\\boldsymbol {\\mu }}^{\\mathsf {T}}}\n  \n often dominates, forcing the leading eigenvector to point almost exactly toward the mean and obliterating any structure in the centred part \n  \n    \n      \n        \n          Z\n        \n      \n    \n    {\\displaystyle \\mathbf {Z} }\n  \n.  \nAfter mean subtraction that term vanishes and the principal axes align with the true directions of maximal variance.\nMean-centering is unnecessary if performing a principal components analysis on a correlation matrix, as the data are already centered after calculating correlations. Correlations are derived from the cross-product of two standard scores (Z-scores) or statistical moments (hence the name: Pearson Product-Moment Correlation). Also see the article by Kromrey & Foster-Johnson (1998) on \"Mean-centering in Moderated Regression: Much Ado About Nothing\". Since covariances are correlations of normalized variables (Z- or standard-scores) a PCA based on the correlation matrix of X is equal to a PCA based on the covariance matrix of Z, the standardized version of X.\nPCA is a popular primary technique in pattern recognition. It is not, however, optimized for class separability. However, it has been used to quantify the distance between two or more classes by calculating center of mass for each class in principal component space and reporting Euclidean distance between center of mass of two or more classes. The linear discriminant analysis is an alternative which is optimized for class separability.\n\n\n== Table of symbols and abbreviations ==\n\n\n== Properties and limitations ==\n\n\n=== Properties ===\nSome properties of PCA include:\n\nProperty 1: For any integer q, 1 ≤ q ≤ p, consider the orthogonal linear transformation\n\n  \n    \n      \n        y\n        =\n        \n          \n            B\n            ′\n          \n        \n        x\n      \n    \n    {\\displaystyle y=\\mathbf {B'} x}\n  \n\nwhere \n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n is a q-element vector and \n  \n    \n      \n        \n          \n            B\n            ′\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {B'} }\n  \n is a (q × p) matrix, and let \n  \n    \n      \n        \n          \n            Σ\n          \n          \n            y\n          \n        \n        =\n        \n          \n            B\n            ′\n          \n        \n        \n          Σ\n        \n        \n          B\n        \n      \n    \n    {\\displaystyle \\mathbf {\\Sigma } _{y}=\\mathbf {B'} \\mathbf {\\Sigma } \\mathbf {B} }\n  \n be the variance-covariance matrix for \n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n. Then the trace of \n  \n    \n      \n        \n          \n            Σ\n          \n          \n            y\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {\\Sigma } _{y}}\n  \n, denoted \n  \n    \n      \n        tr\n        ⁡\n        (\n        \n          \n            Σ\n          \n          \n            y\n          \n        \n        )\n      \n    \n    {\\displaystyle \\operatorname {tr} (\\mathbf {\\Sigma } _{y})}\n  \n, is maximized by taking \n  \n    \n      \n        \n          B\n        \n        =\n        \n          \n            A\n          \n          \n            q\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {B} =\\mathbf {A} _{q}}\n  \n, where \n  \n    \n      \n        \n          \n            A\n          \n          \n            q\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {A} _{q}}\n  \n consists of the first q columns of \n  \n    \n      \n        \n          A\n        \n      \n    \n    {\\displaystyle \\mathbf {A} }\n  \n \n  \n    \n      \n        (\n        \n          \n            B\n            ′\n          \n        \n      \n    \n    {\\displaystyle (\\mathbf {B'} }\n  \n is the transpose of \n  \n    \n      \n        \n          B\n        \n        )\n      \n    \n    {\\displaystyle \\mathbf {B} )}\n  \n. (\n  \n    \n      \n        \n          A\n        \n      \n    \n    {\\displaystyle \\mathbf {A} }\n  \n is not defined here)\nProperty 2: Consider again the orthonormal transformation\n\n  \n    \n      \n        y\n        =\n        \n          \n            B\n            ′\n          \n        \n        x\n      \n    \n    {\\displaystyle y=\\mathbf {B'} x}\n  \n\nwith \n  \n    \n      \n        x\n        ,\n        \n          B\n        \n        ,\n        \n          A\n        \n      \n    \n    {\\displaystyle x,\\mathbf {B} ,\\mathbf {A} }\n  \n and \n  \n    \n      \n        \n          \n            Σ\n          \n          \n            y\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {\\Sigma } _{y}}\n  \n defined as before. Then \n  \n    \n      \n        tr\n        ⁡\n        (\n        \n          \n            Σ\n          \n          \n            y\n          \n        \n        )\n      \n    \n    {\\displaystyle \\operatorname {tr} (\\mathbf {\\Sigma } _{y})}\n  \n is minimized by taking \n  \n    \n      \n        \n          B\n        \n        =\n        \n          \n            A\n          \n          \n            q\n          \n          \n            ∗\n          \n        \n        ,\n      \n    \n    {\\displaystyle \\mathbf {B} =\\mathbf {A} _{q}^{*},}\n  \n where \n  \n    \n      \n        \n          \n            A\n          \n          \n            q\n          \n          \n            ∗\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {A} _{q}^{*}}\n  \n consists of the last q columns of \n  \n    \n      \n        \n          A\n        \n      \n    \n    {\\displaystyle \\mathbf {A} }\n  \n.\nThe statistical implication of this property is that the last few PCs are not simply unstructured left-overs after removing the important PCs. Because these last PCs have variances as small as possible they are useful in their own right. They can help to detect unsuspected near-constant linear relationships between the elements of x, and they may also be useful in regression, in selecting a subset of variables from x, and in outlier detection.\n\nProperty 3: (Spectral decomposition of Σ)\n\n  \n    \n      \n        \n          Σ\n        \n        =\n        \n          λ\n          \n            1\n          \n        \n        \n          α\n          \n            1\n          \n        \n        \n          α\n          \n            1\n          \n          ′\n        \n        +\n        ⋯\n        +\n        \n          λ\n          \n            p\n          \n        \n        \n          α\n          \n            p\n          \n        \n        \n          α\n          \n            p\n          \n          ′\n        \n      \n    \n    {\\displaystyle \\mathbf {\\Sigma } =\\lambda _{1}\\alpha _{1}\\alpha _{1}'+\\cdots +\\lambda _{p}\\alpha _{p}\\alpha _{p}'}\n  \n\nBefore we look at its usage, we first look at diagonal elements,\n\n  \n    \n      \n        Var\n        ⁡\n        (\n        \n          x\n          \n            j\n          \n        \n        )\n        =\n        \n          ∑\n          \n            k\n            =\n            1\n          \n          \n            P\n          \n        \n        \n          λ\n          \n            k\n          \n        \n        \n          α\n          \n            k\n            j\n          \n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\operatorname {Var} (x_{j})=\\sum _{k=1}^{P}\\lambda _{k}\\alpha _{kj}^{2}}\n  \n\nThen, perhaps the main statistical implication of the result is that not only can we decompose the combined variances of all the elements of x into decreasing contributions due to each PC, but we can also decompose the whole covariance matrix into contributions \n  \n    \n      \n        \n          λ\n          \n            k\n          \n        \n        \n          α\n          \n            k\n          \n        \n        \n          α\n          \n            k\n          \n          ′\n        \n      \n    \n    {\\displaystyle \\lambda _{k}\\alpha _{k}\\alpha _{k}'}\n  \n from each PC. Although not strictly decreasing, the elements of \n  \n    \n      \n        \n          λ\n          \n            k\n          \n        \n        \n          α\n          \n            k\n          \n        \n        \n          α\n          \n            k\n          \n          ′\n        \n      \n    \n    {\\displaystyle \\lambda _{k}\\alpha _{k}\\alpha _{k}'}\n  \n will tend to become smaller as \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n increases, as \n  \n    \n      \n        \n          λ\n          \n            k\n          \n        \n        \n          α\n          \n            k\n          \n        \n        \n          α\n          \n            k\n          \n          ′\n        \n      \n    \n    {\\displaystyle \\lambda _{k}\\alpha _{k}\\alpha _{k}'}\n  \n is nonincreasing for increasing \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n, whereas the elements of \n  \n    \n      \n        \n          α\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle \\alpha _{k}}\n  \n tend to stay about the same size because of the normalization constraints: \n  \n    \n      \n        \n          α\n          \n            k\n          \n          ′\n        \n        \n          α\n          \n            k\n          \n        \n        =\n        1\n        ,\n        k\n        =\n        1\n        ,\n        …\n        ,\n        p\n      \n    \n    {\\displaystyle \\alpha _{k}'\\alpha _{k}=1,k=1,\\dots ,p}\n  \n.\n\n\n=== Limitations ===\nAs noted above, the results of PCA depend on the scaling of the variables. This can be cured by scaling each feature by its standard deviation, so that one ends up with dimensionless features with unital variance.\nThe applicability of PCA as described above is limited by certain (tacit) assumptions made in its derivation. In particular, PCA can capture linear correlations between the features but fails when this assumption is violated (see Figure 6a in the reference). In some cases, coordinate transformations can restore the linearity assumption and PCA can then be applied (see kernel PCA).\nAnother limitation is the mean-removal process before constructing the covariance matrix for PCA. In fields such as astronomy, all the signals are non-negative, and the mean-removal process will force the mean of some astrophysical exposures to be zero, which consequently creates unphysical negative fluxes, and forward modeling has to be performed to recover the true magnitude of the signals. As an alternative method, non-negative matrix factorization focusing only on the non-negative elements in the matrices is well-suited for astrophysical observations. See more at the relation between PCA and non-negative matrix factorization.\nPCA is at a disadvantage if the data has not been standardized before applying the algorithm to it. PCA transforms the original data into data that is relevant to the principal components of that data, which means that the new data variables cannot be interpreted in the same ways that the originals were. They are linear interpretations of the original variables. Also, if PCA is not performed properly, there is a high likelihood of information loss.\nPCA relies on a linear model. If a dataset has a pattern hidden inside it that is nonlinear, then PCA can actually steer the analysis in the complete opposite direction of progress. Researchers at Kansas State University discovered that the sampling error in their experiments impacted the bias of PCA results. \"If the number of subjects or blocks is smaller than 30, and/or the researcher is interested in PC's beyond the first, it may be better to first correct for the serial correlation, before PCA is conducted\". The researchers at Kansas State also found that PCA could be \"seriously biased if the autocorrelation structure of the data are not correctly handled\".\n\n\n=== PCA and information theory ===\nDimensionality reduction results in a loss of information, in general. PCA-based dimensionality reduction tends to minimize that information loss, under certain signal and noise models.\nUnder the assumption that\n\n  \n    \n      \n        \n          x\n        \n        =\n        \n          s\n        \n        +\n        \n          n\n        \n        ,\n      \n    \n    {\\displaystyle \\mathbf {x} =\\mathbf {s} +\\mathbf {n} ,}\n  \n\nthat is, that the data vector \n  \n    \n      \n        \n          x\n        \n      \n    \n    {\\displaystyle \\mathbf {x} }\n  \n is the sum of the desired information-bearing signal \n  \n    \n      \n        \n          s\n        \n      \n    \n    {\\displaystyle \\mathbf {s} }\n  \n and a noise signal \n  \n    \n      \n        \n          n\n        \n      \n    \n    {\\displaystyle \\mathbf {n} }\n  \n one can show that PCA can be optimal for dimensionality reduction, from an information-theoretic point-of-view.\nIn particular, Linsker showed that if \n  \n    \n      \n        \n          s\n        \n      \n    \n    {\\displaystyle \\mathbf {s} }\n  \n is Gaussian and \n  \n    \n      \n        \n          n\n        \n      \n    \n    {\\displaystyle \\mathbf {n} }\n  \n is Gaussian noise with a covariance matrix proportional to the identity matrix, the PCA maximizes the mutual information \n  \n    \n      \n        I\n        (\n        \n          y\n        \n        ;\n        \n          s\n        \n        )\n      \n    \n    {\\displaystyle I(\\mathbf {y} ;\\mathbf {s} )}\n  \n between the desired information \n  \n    \n      \n        \n          s\n        \n      \n    \n    {\\displaystyle \\mathbf {s} }\n  \n and the dimensionality-reduced output \n  \n    \n      \n        \n          y\n        \n        =\n        \n          \n            W\n          \n          \n            L\n          \n          \n            T\n          \n        \n        \n          x\n        \n      \n    \n    {\\displaystyle \\mathbf {y} =\\mathbf {W} _{L}^{T}\\mathbf {x} }\n  \n.\nIf the noise is still Gaussian and has a covariance matrix proportional to the identity matrix (that is, the components of the vector \n  \n    \n      \n        \n          n\n        \n      \n    \n    {\\displaystyle \\mathbf {n} }\n  \n are iid), but the information-bearing signal \n  \n    \n      \n        \n          s\n        \n      \n    \n    {\\displaystyle \\mathbf {s} }\n  \n is non-Gaussian (which is a common scenario), PCA at least minimizes an upper bound on the information loss, which is defined as\n\n  \n    \n      \n        I\n        (\n        \n          x\n        \n        ;\n        \n          s\n        \n        )\n        −\n        I\n        (\n        \n          y\n        \n        ;\n        \n          s\n        \n        )\n        .\n      \n    \n    {\\displaystyle I(\\mathbf {x} ;\\mathbf {s} )-I(\\mathbf {y} ;\\mathbf {s} ).}\n  \n\nThe optimality of PCA is also preserved if the noise \n  \n    \n      \n        \n          n\n        \n      \n    \n    {\\displaystyle \\mathbf {n} }\n  \n is iid and at least more Gaussian (in terms of the Kullback–Leibler divergence) than the information-bearing signal \n  \n    \n      \n        \n          s\n        \n      \n    \n    {\\displaystyle \\mathbf {s} }\n  \n. In general, even if the above signal model holds, PCA loses its information-theoretic optimality as soon as the noise \n  \n    \n      \n        \n          n\n        \n      \n    \n    {\\displaystyle \\mathbf {n} }\n  \n becomes dependent.\n\n\n== Computation using the covariance method ==\nThe following is a detailed description of PCA using the covariance method as opposed to the correlation method.\nThe goal is to transform a given data set X of dimension p to an alternative data set Y of smaller dimension L. Equivalently, we are seeking to find the matrix Y, where Y is the Karhunen–Loève transform (KLT) of matrix X:\n\n  \n    \n      \n        \n          Y\n        \n        =\n        \n          K\n          L\n          T\n        \n        {\n        \n          X\n        \n        }\n      \n    \n    {\\displaystyle \\mathbf {Y} =\\mathbb {KLT} \\{\\mathbf {X} \\}}\n  \n\nOrganize the data set\n\nSuppose you have data comprising a set of observations of p variables, and you want to reduce the data so that each observation can be described with only L variables, L < p. Suppose further, that the data are arranged as a set of n data vectors \n  \n    \n      \n        \n          \n            x\n          \n          \n            1\n          \n        \n        …\n        \n          \n            x\n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {x} _{1}\\ldots \\mathbf {x} _{n}}\n  \n with each \n  \n    \n      \n        \n          \n            x\n          \n          \n            i\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {x} _{i}}\n  \n representing a single grouped observation of the p variables.\n\nWrite \n  \n    \n      \n        \n          \n            x\n          \n          \n            1\n          \n        \n        …\n        \n          \n            x\n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {x} _{1}\\ldots \\mathbf {x} _{n}}\n  \n as row vectors, each with p elements.\nPlace the row vectors into a single matrix X of dimensions n × p.\n\nCalculate the empirical mean\n\nFind the empirical mean along each column j = 1, ..., p.\nPlace the calculated mean values into an empirical mean vector u of dimensions p × 1. \n  \n    \n      \n        \n          u\n          \n            j\n          \n        \n        =\n        \n          \n            1\n            n\n          \n        \n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          X\n          \n            i\n            j\n          \n        \n      \n    \n    {\\displaystyle u_{j}={\\frac {1}{n}}\\sum _{i=1}^{n}X_{ij}}\n  \n\nCalculate the deviations from the mean\n\nMean subtraction is an integral part of the solution towards finding a principal component basis that minimizes the mean square error of approximating the data. Hence we proceed by centering the data as follows:\n\nSubtract the empirical mean vector \n  \n    \n      \n        \n          \n            u\n          \n          \n            T\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {u} ^{T}}\n  \n from each row of the data matrix X.\nStore mean-subtracted data in the n × p matrix B. \n  \n    \n      \n        \n          B\n        \n        =\n        \n          X\n        \n        −\n        \n          h\n        \n        \n          \n            u\n          \n          \n            T\n          \n        \n      \n    \n    {\\displaystyle \\mathbf {B} =\\mathbf {X} -\\mathbf {h} \\mathbf {u} ^{T}}\n  \n where h is an n × 1 column vector of all 1s: \n  \n    \n      \n        \n          h\n          \n            i\n          \n        \n        =\n        1\n        \n        \n        \n        \n          for \n        \n        i\n        =\n        1\n        ,\n        …\n        ,\n        n\n      \n    \n    {\\displaystyle h_{i}=1\\,\\qquad \\qquad {\\text{for }}i=1,\\ldots ,n}\n  \n\nIn some applications, each variable (column of B) may also be scaled to have a variance equal to 1 (see Z-score). This step affects the calculated principal components, but makes them independent of the units used to measure the different variables.\n\nFind the covariance matrix\n\nFind the p × p empirical covariance matrix C from matrix B: \n  \n    \n      \n        \n          C\n        \n        =\n        \n          \n            1\n            \n              n\n              −\n              1\n            \n          \n        \n        \n          \n            B\n          \n          \n            ∗\n          \n        \n        \n          B\n        \n      \n    \n    {\\displaystyle \\mathbf {C} ={1 \\over {n-1}}\\mathbf {B} ^{*}\\mathbf {B} }\n  \n where \n  \n    \n      \n        ∗\n      \n    \n    {\\displaystyle *}\n  \n is the conjugate transpose operator. If B consists entirely of real numbers, which is the case in many applications, the \"conjugate transpose\" is the same as the regular transpose.\nThe reasoning behind using n − 1 instead of n to calculate the covariance is Bessel's correction.\n\nFind the eigenvectors and eigenvalues of the covariance matrix\n\nCompute the matrix V of eigenvectors which diagonalizes the covariance matrix C: \n  \n    \n      \n        \n          \n            V\n          \n          \n            −\n            1\n          \n        \n        \n          C\n        \n        \n          V\n        \n        =\n        \n          D\n        \n      \n    \n    {\\displaystyle \\mathbf {V} ^{-1}\\mathbf {C} \\mathbf {V} =\\mathbf {D} }\n  \n where D is the diagonal matrix of eigenvalues of C. This step will typically involve the use of a computer-based algorithm for computing eigenvectors and eigenvalues. These algorithms are readily available as sub-components of most matrix algebra systems, such as SAS, R, MATLAB, Mathematica, SciPy, IDL (Interactive Data Language), or GNU Octave as well as OpenCV.\nMatrix D will take the form of an p × p diagonal matrix, where \n  \n    \n      \n        \n          D\n          \n            k\n            ℓ\n          \n        \n        =\n        \n          λ\n          \n            k\n          \n        \n        \n        \n          for \n        \n        k\n        =\n        ℓ\n      \n    \n    {\\displaystyle D_{k\\ell }=\\lambda _{k}\\qquad {\\text{for }}k=\\ell }\n  \n is the jth eigenvalue of the covariance matrix C, and \n  \n    \n      \n        \n          D\n          \n            k\n            ℓ\n          \n        \n        =\n        0\n        \n        \n          for \n        \n        k\n        ≠\n        ℓ\n        .\n      \n    \n    {\\displaystyle D_{k\\ell }=0\\qquad {\\text{for }}k\\neq \\ell .}\n  \n\nMatrix V, also of dimension p × p, contains p column vectors, each of length p, which represent the p eigenvectors of the covariance matrix C.\nThe eigenvalues and eigenvectors are ordered and paired. The jth eigenvalue corresponds to the jth eigenvector.\nMatrix V denotes the matrix of right eigenvectors (as opposed to left eigenvectors). In general, the matrix of right eigenvectors need not be the (conjugate) transpose of the matrix of left eigenvectors.\n\nRearrange the eigenvectors and eigenvalues\n\nSort the columns of the eigenvector matrix V and eigenvalue matrix D in order of decreasing eigenvalue.\nMake sure to maintain the correct pairings between the columns in each matrix.\n\nCompute the cumulative energy content for each eigenvector\nThe eigenvalues represent the distribution of the source data's energy among each of the eigenvectors, where the eigenvectors form a basis for the data. The cumulative energy content g for the jth eigenvector is the sum of the energy content across all of the eigenvalues from 1 through j divided by the sum of energy content across all eigenvalues (shown in step 8): \n  \n    \n      \n        \n          g\n          \n            j\n          \n        \n        =\n        \n          ∑\n          \n            k\n            =\n            1\n          \n          \n            j\n          \n        \n        \n          D\n          \n            k\n            k\n          \n        \n        \n        \n          for \n        \n        j\n        =\n        1\n        ,\n        …\n        ,\n        p\n      \n    \n    {\\displaystyle g_{j}=\\sum _{k=1}^{j}D_{kk}\\qquad {\\text{for }}j=1,\\dots ,p}\n  \n\nSelect a subset of the eigenvectors as basis vectors\n\nSave the first L columns of V as the p × L matrix W: \n  \n    \n      \n        \n          W\n          \n            k\n            l\n          \n        \n        =\n        \n          V\n          \n            k\n            ℓ\n          \n        \n        \n        \n          for \n        \n        k\n        =\n        1\n        ,\n        …\n        ,\n        p\n        \n        ℓ\n        =\n        1\n        ,\n        …\n        ,\n        L\n      \n    \n    {\\displaystyle W_{kl}=V_{k\\ell }\\qquad {\\text{for }}k=1,\\dots ,p\\qquad \\ell =1,\\dots ,L}\n  \n where \n  \n    \n      \n        1\n        ≤\n        L\n        ≤\n        p\n        .\n      \n    \n    {\\displaystyle 1\\leq L\\leq p.}\n  \n\nUse the vector g as a guide in choosing an appropriate value for L. The goal is to choose a value of L as small as possible while achieving a reasonably high value of g on a percentage basis. For example, you may want to choose L so that the cumulative energy g is above a certain threshold, like 90 percent. In this case, choose the smallest value of L such that \n  \n    \n      \n        \n          \n            \n              g\n              \n                L\n              \n            \n            \n              g\n              \n                p\n              \n            \n          \n        \n        ≥\n        0.9\n      \n    \n    {\\displaystyle {\\frac {g_{L}}{g_{p}}}\\geq 0.9}\n  \n\nProject the data onto the new basis\n\nThe projected data points are the rows of the matrix \n  \n    \n      \n        \n          T\n        \n        =\n        \n          B\n        \n        ⋅\n        \n          W\n        \n      \n    \n    {\\displaystyle \\mathbf {T} =\\mathbf {B} \\cdot \\mathbf {W} }\n  \n\nThat is, the first column of \n  \n    \n      \n        \n          T\n        \n      \n    \n    {\\displaystyle \\mathbf {T} }\n  \n is the projection of the data points onto the first principal component, the second column is the projection onto the second principal component, etc.\n\n\n== Derivation using the covariance method ==\nLet X be a d-dimensional random vector expressed as column vector. Without loss of generality, assume X has zero mean.\nWe want to find \n  \n    \n      \n        (\n        ∗\n        )\n      \n    \n    {\\displaystyle (\\ast )}\n  \n a d × d orthonormal transformation matrix P so that PX has a diagonal covariance matrix (that is, PX is a random vector with all its distinct components pairwise uncorrelated).\nA quick computation assuming \n  \n    \n      \n        P\n      \n    \n    {\\displaystyle P}\n  \n were unitary yields:\n\n  \n    \n      \n        \n          \n            \n              \n                cov\n                ⁡\n                (\n                P\n                X\n                )\n              \n              \n                \n                =\n                E\n                ⁡\n                [\n                P\n                X\n                 \n                (\n                P\n                X\n                \n                  )\n                  \n                    ∗\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                E\n                ⁡\n                [\n                P\n                X\n                 \n                \n                  X\n                  \n                    ∗\n                  \n                \n                \n                  P\n                  \n                    ∗\n                  \n                \n                ]\n              \n            \n            \n              \n              \n                \n                =\n                P\n                E\n                ⁡\n                [\n                X\n                \n                  X\n                  \n                    ∗\n                  \n                \n                ]\n                \n                  P\n                  \n                    ∗\n                  \n                \n              \n            \n            \n              \n              \n                \n                =\n                P\n                cov\n                ⁡\n                (\n                X\n                )\n                \n                  P\n                  \n                    −\n                    1\n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}\\operatorname {cov} (PX)&=\\operatorname {E} [PX~(PX)^{*}]\\\\&=\\operatorname {E} [PX~X^{*}P^{*}]\\\\&=P\\operatorname {E} [XX^{*}]P^{*}\\\\&=P\\operatorname {cov} (X)P^{-1}\\\\\\end{aligned}}}\n  \n\nHence \n  \n    \n      \n        (\n        ∗\n        )\n      \n    \n    {\\displaystyle (\\ast )}\n  \n holds if and only if \n  \n    \n      \n        cov\n        ⁡\n        (\n        X\n        )\n      \n    \n    {\\displaystyle \\operatorname {cov} (X)}\n  \n were diagonalisable by \n  \n    \n      \n        P\n      \n    \n    {\\displaystyle P}\n  \n.\nThis is very constructive, as cov(X) is guaranteed to be a non-negative definite matrix and thus is guaranteed to be diagonalisable by some unitary matrix.\n\n\n== Covariance-free computation ==\nIn practical implementations, especially with high dimensional data (large p), the naive covariance method is rarely used because it is not efficient due to high computational and memory costs of explicitly determining the covariance matrix. The covariance-free approach avoids the np2 operations of explicitly calculating and storing the covariance matrix XTX, instead utilizing one of matrix-free methods, for example, based on the function evaluating the product XT(X r) at the cost of 2np operations.\n\n\n=== Iterative computation ===\nOne way to compute the first principal component efficiently is shown in the following pseudo-code, for a data matrix X with zero mean, without ever computing its covariance matrix.\n\nr = a random vector of length p\nr = r / norm(r)\ndo c times:\n      s = 0 (a vector of length p)\n      for each row x in X\n            s = s + (x ⋅ r) x\n      λ = rTs // λ is the eigenvalue\n      error = |λ ⋅ r − s|\n      r = s / norm(s)\n      exit if error < tolerance\nreturn λ, r\n\nThis power iteration algorithm simply calculates the vector XT(X r), normalizes, and places the result back in r. The eigenvalue is approximated by rT (XTX) r, which is the Rayleigh quotient on the unit vector r for the covariance matrix XTX . If the largest singular value is well separated from the next largest one, the vector r gets close to the first principal component of X within the number of iterations c, which is small relative to p, at the total cost 2cnp. The power iteration convergence can be accelerated without noticeably sacrificing the small cost per iteration using more advanced matrix-free methods, such as the Lanczos algorithm or the Locally Optimal Block Preconditioned Conjugate Gradient (LOBPCG) method.\nSubsequent principal components can be computed one-by-one via deflation or simultaneously as a block. In the former approach, imprecisions in already computed approximate principal components additively affect the accuracy of the subsequently computed principal components, thus increasing the error with every new computation. The latter approach in the block power method replaces single-vectors r and s with block-vectors, matrices R and S. Every column of R approximates one of the leading principal components, while all columns are iterated simultaneously. The main calculation is evaluation of the product XT(X R). Implemented, for example, in LOBPCG, efficient blocking eliminates the accumulation of the errors, allows using high-level BLAS matrix-matrix product functions, and typically leads to faster convergence, compared to the single-vector one-by-one technique.\n\n\n=== The NIPALS method ===\nNon-linear iterative partial least squares (NIPALS) is a variant the classical power iteration with matrix deflation by subtraction implemented for computing the first few components in a principal component or partial least squares analysis. For very-high-dimensional datasets, such as those generated in the *omics sciences (for example, genomics, metabolomics) it is usually only necessary to compute the first few PCs. The non-linear iterative partial least squares (NIPALS) algorithm updates iterative approximations to the leading scores and loadings t1 and r1T by the power iteration multiplying on every iteration by X on the left and on the right, that is, calculation of the covariance matrix is avoided, just as in the matrix-free implementation of the power iterations to XTX, based on the function evaluating the product XT(X r) = ((X r)TX)T.\nThe matrix deflation by subtraction is performed by subtracting the outer product, t1r1T from X leaving the deflated residual matrix used to calculate the subsequent leading PCs.\nFor large data matrices, or matrices that have a high degree of column collinearity, NIPALS suffers from loss of orthogonality of PCs due to machine precision round-off errors accumulated in each iteration and matrix deflation by subtraction. A Gram–Schmidt re-orthogonalization algorithm is applied to both the scores and the loadings at each iteration step to eliminate this loss of orthogonality. NIPALS reliance on single-vector multiplications cannot take advantage of high-level BLAS and results in slow convergence for clustered leading singular values—both these deficiencies are resolved in more sophisticated matrix-free block solvers, such as the Locally Optimal Block Preconditioned Conjugate Gradient (LOBPCG) method.\n\n\n=== Online/sequential estimation ===\nIn an \"online\" or \"streaming\" situation with data arriving piece by piece rather than being stored in a single batch, it is useful to make an estimate of the PCA projection that can be updated sequentially. This can be done efficiently, but requires different algorithms.\n\n\n== Qualitative variables ==\nIn PCA, it is common that we want to introduce qualitative variables as supplementary elements. For example, many quantitative variables have been measured on plants. For these plants, some qualitative variables are available as, for example, the species to which the plant belongs. These data were subjected to PCA for quantitative variables. When analyzing the results, it is natural to connect the principal components to the qualitative variable species.\nFor this, the following results are produced.\n\nIdentification, on the factorial planes, of the different species, for example, using different colors.\nRepresentation, on the factorial planes, of the centers of gravity of plants belonging to the same species.\nFor each center of gravity and each axis, p-value to judge the significance of the difference between the center of gravity and origin.\nThese results are what is called introducing a qualitative variable as supplementary element. This procedure is detailed in and Husson, Lê, & Pagès (2009) and Pagès (2013).\nFew software offer this option in an \"automatic\" way. This is the case of SPAD that historically, following the work of Ludovic Lebart, was the first to propose this option, and the R package FactoMineR.\n\n\n== Applications ==\n\n\n=== Intelligence ===\nThe earliest application of factor analysis was in locating and measuring components of human intelligence. It was believed that intelligence had various uncorrelated components such as spatial intelligence, verbal intelligence, induction, deduction etc and that scores on these could be adduced by factor analysis from results on various tests, to give a single index known as the Intelligence Quotient (IQ). The pioneering statistical psychologist Spearman actually developed factor analysis in 1904 for his two-factor theory of intelligence, adding a formal technique to the science of psychometrics. In 1924 Thurstone looked for 56 factors of intelligence, developing the notion of Mental Age. Standard IQ tests today are based on this early work.\n\n\n=== Residential differentiation ===\nIn 1949, Shevky and Williams introduced the theory of factorial ecology, which dominated studies of residential differentiation from the 1950s to the 1970s. Neighbourhoods in a city were recognizable or could be distinguished from one another by various characteristics which could be reduced to three by factor analysis. These were known as 'social rank' (an index of occupational status), 'familism' or family size, and 'ethnicity'; Cluster analysis could then be applied to divide the city into clusters or precincts according to values of the three key factor variables. An extensive literature developed around factorial ecology in urban geography, but the approach went out of fashion after 1980 as being methodologically primitive and having little place in postmodern geographical paradigms.\nOne of the problems with factor analysis has always been finding convincing names for the various artificial factors. In 2000, Flood revived the factorial ecology approach to show that principal components analysis actually gave meaningful answers directly, without resorting to factor rotation. The principal components were actually dual variables or shadow prices of 'forces' pushing people together or apart in cities. The first component was 'accessibility', the classic trade-off between demand for travel and demand for space, around which classical urban economics is based. The next two components were 'disadvantage', which keeps people of similar status in separate neighbourhoods (mediated by planning), and ethnicity, where people of similar ethnic backgrounds try to co-locate.\nAbout the same time, the Australian Bureau of Statistics defined distinct indexes of advantage and disadvantage taking the first principal component of sets of key variables that were thought to be important. These SEIFA indexes are regularly published for various jurisdictions, and are used frequently in spatial analysis.\n\n\n=== Development indexes ===\nPCA can be used as a formal method for the development of indexes. As an alternative confirmatory composite analysis has been proposed to develop and assess indexes.\nThe City Development Index was developed by PCA from about 200 indicators of city outcomes in a 1996 survey of 254 global cities. The first principal component was subject to iterative regression, adding the original variables singly until about 90% of its variation was accounted for. The index ultimately used about 15 indicators but was a good predictor of many more variables. Its comparative value agreed very well with a subjective assessment of the condition of each city. The coefficients on items of infrastructure were roughly proportional to the average costs of providing the underlying services, suggesting the Index was actually a measure of effective physical and social investment in the city.\nThe country-level Human Development Index (HDI) from UNDP, which has been published since 1990 and is very extensively used in development studies, has very similar coefficients on similar indicators, strongly suggesting it was originally constructed using PCA.\n\n\n=== Population genetics ===\nIn 1978 Cavalli-Sforza and others pioneered the use of principal components analysis (PCA) to summarise data on variation in human gene frequencies across regions. The components showed distinctive patterns, including gradients and sinusoidal waves. They interpreted these patterns as resulting from specific ancient migration events.\nSince then, PCA has been ubiquitous in population genetics, with thousands of papers using PCA as a display mechanism. Genetics varies largely according to proximity, so the first two principal components actually show spatial distribution and may be used to map the relative geographical location of different population groups, thereby showing individuals who have wandered from their original locations.\nPCA in genetics has been technically controversial, in that the technique has been performed on discrete non-normal variables and often on binary allele markers. The lack of any measures of standard error in PCA are also an impediment to more consistent usage. In August 2022, the molecular biologist Eran Elhaik published a theoretical paper in Scientific Reports analyzing 12 PCA applications. He concluded that it was easy to manipulate the method, which, in his view, generated results that were 'erroneous, contradictory, and absurd.' Specifically, he argued, the results achieved in population genetics were characterized by cherry-picking and circular reasoning.\n\n\n=== Market research and indexes of attitude ===\nMarket research has been an extensive user of PCA. It is used to develop customer satisfaction or customer loyalty scores for products, and with clustering, to develop market segments that may be targeted with advertising campaigns, in much the same way as factorial ecology will locate geographical areas with similar characteristics.\nPCA rapidly transforms large amounts of data into smaller, easier-to-digest variables that can be more rapidly and readily analyzed. In any consumer questionnaire, there are series of questions designed to elicit consumer attitudes, and principal components seek out latent variables underlying these attitudes. For example, the Oxford Internet Survey in 2013 asked 2000 people about their attitudes and beliefs, and from these analysts extracted four principal component dimensions, which they identified as 'escape', 'social networking', 'efficiency', and 'problem creating'.\nAnother example from Joe Flood in 2008 extracted an attitudinal index toward housing from 28 attitude questions in a national survey of 2697 households in Australia. The first principal component represented a general attitude toward property and home ownership. The index, or the attitude questions it embodied, could be fed into a General Linear Model of tenure choice. The strongest determinant of private renting by far was the attitude index, rather than income, marital status or household type.\n\n\n=== Quantitative finance ===\nIn quantitative finance, PCA is used\nin financial risk management, and has been applied to other problems such as portfolio optimization.\nPCA is commonly used in problems involving fixed income securities and portfolios, and interest rate derivatives. \nValuations here depend on the entire yield curve, comprising numerous highly correlated instruments, and PCA is used to define a set of components or factors that explain rate movements,\nthereby facilitating the modelling.\nOne common risk management application is to calculating value at risk, VaR, applying PCA to the Monte Carlo simulation.\n\nHere, for each simulation-sample, the components are stressed, and rates, and in turn option values, are then reconstructed; \nwith VaR calculated, finally, over the entire run. \nPCA is also used in hedging exposure to interest rate risk, given partial durations and other sensitivities.\n\nUnder both, the first three, typically, principal components of the system are of interest (representing \"shift\", \"twist\", and \"curvature\").\nThese principal components are derived from an eigen-decomposition of the covariance matrix of yield at predefined maturities; \n\nand where the variance of each component is its eigenvalue (and as the components are orthogonal, no correlation need be incorporated in subsequent modelling).\nFor equity, an optimal portfolio is one where the expected return is maximized for a given level of risk, or alternatively, where risk is minimized for a given return; see Markowitz model for discussion.\nThus, one approach is to reduce portfolio risk, where allocation strategies are applied to the \"principal portfolios\" instead of the underlying stocks.\nA second approach is to enhance portfolio return, using the principal components to select companies' stocks with upside potential.\n \n\nPCA has also been used to understand relationships  between international equity markets, and within markets between groups of companies in industries or sectors.\nPCA may also be applied to stress testing, essentially an analysis of a bank's ability to endure a hypothetical adverse economic scenario. Its utility is in \"distilling the information contained in [several] macroeconomic variables into a more manageable data set, which can then [be used] for analysis.\" Here, the resulting factors are linked to e.g. interest rates – based on the largest elements of the factor's eigenvector – and it is then observed how a \"shock\" to each of the factors affects the implied assets of each of the banks.\n\n\n=== Neuroscience ===\nA variant of principal components analysis is used in neuroscience to identify the specific properties of a stimulus that increases a neuron's probability of generating an action potential. This technique is known as spike-triggered covariance analysis. In a typical application an experimenter presents a white noise process as a stimulus (usually either as a sensory input to a test subject, or as a current injected directly into the neuron) and records a train of action potentials, or spikes, produced by the neuron as a result. Presumably, certain features of the stimulus make the neuron more likely to spike. In order to extract these features, the experimenter calculates the covariance matrix of the spike-triggered ensemble, the set of all stimuli (defined and discretized over a finite time window, typically on the order of 100 ms) that immediately preceded a spike. The eigenvectors of the difference between the spike-triggered covariance matrix and the covariance matrix of the prior stimulus ensemble (the set of all stimuli, defined over the same length time window) then indicate the directions in the space of stimuli along which the variance of the spike-triggered ensemble differed the most from that of the prior stimulus ensemble. Specifically, the eigenvectors with the largest positive eigenvalues correspond to the directions along which the variance of the spike-triggered ensemble showed the largest positive change compared to the variance of the prior. Since these were the directions in which varying the stimulus led to a spike, they are often good approximations of the sought after relevant stimulus features.\nIn neuroscience, PCA is also used to discern the identity of a neuron from the shape of its action potential. Spike sorting is an important procedure because extracellular recording techniques often pick up signals from more than one neuron. In spike sorting, one first uses PCA to reduce the dimensionality of the space of action potential waveforms, and then performs clustering analysis to associate specific action potentials with individual neurons.\nPCA as a dimension reduction technique is particularly suited to detect coordinated activities of large neuronal ensembles. It has been used in determining collective variables, that is, order parameters, during phase transitions in the brain.\n\n\n== Relation with other methods ==\n\n\n=== Correspondence analysis ===\nCorrespondence analysis (CA)\nwas developed by Jean-Paul Benzécri\nand is conceptually similar to PCA, but scales the data (which should be non-negative) so that rows and columns are treated equivalently. It is traditionally applied to contingency tables.\nCA decomposes the chi-squared statistic associated to this table into orthogonal factors.\nBecause CA is a descriptive technique, it can be applied to tables for which the chi-squared statistic is appropriate or not.\nSeveral variants of CA are available including detrended correspondence analysis and canonical correspondence analysis. One special extension is multiple correspondence analysis, which may be seen as the counterpart of principal component analysis for categorical data.\n\n\n=== Factor analysis ===\n\nPrincipal component analysis creates variables that are linear combinations of the original variables. The new variables have the property that the variables are all orthogonal. The PCA transformation can be helpful as a pre-processing step before clustering. PCA is a variance-focused approach seeking to reproduce the total variable variance, in which components reflect both common and unique variance of the variable. PCA is generally preferred for purposes of data reduction (that is, translating variable space into optimal factor space) but not when the goal is to detect the latent construct or factors.\nFactor analysis is similar to principal component analysis, in that factor analysis also involves linear combinations of variables. Different from PCA, factor analysis is a correlation-focused approach seeking to reproduce the inter-correlations among variables, in which the factors \"represent the common variance of variables, excluding unique variance\". In terms of the correlation matrix, this corresponds with focusing on explaining the off-diagonal terms (that is, shared co-variance), while PCA focuses on explaining the terms that sit on the diagonal. However, as a side result, when trying to reproduce the on-diagonal terms, PCA also tends to fit relatively well the off-diagonal correlations. Results given by PCA and factor analysis are very similar in most situations, but this is not always the case, and there are some problems where the results are significantly different. Factor analysis is generally used when the research purpose is detecting data structure (that is, latent constructs or factors) or causal modeling. If the factor model is incorrectly formulated or the assumptions are not met, then factor analysis will give erroneous results.\n\n\n=== K-means clustering ===\nIt has been asserted that the relaxed solution of k-means clustering, specified by the cluster indicators, is given by the principal components, and the PCA subspace spanned by the principal directions is identical to the cluster centroid subspace. However, that PCA is a useful relaxation of k-means clustering was not a new result, and it is straightforward to uncover counterexamples to the statement that the cluster centroid subspace is spanned by the principal directions.\n\n\n=== Non-negative matrix factorization ===\n Non-negative matrix factorization (NMF) is a dimension reduction method where only non-negative elements in the matrices are used, which is therefore a promising method in astronomy, in the sense that astrophysical signals are non-negative. The PCA components are orthogonal to each other, while the NMF components are all non-negative and therefore constructs a non-orthogonal basis.\nIn PCA, the contribution of each component is ranked based on the magnitude of its corresponding eigenvalue, which is equivalent to the fractional residual variance (FRV) in analyzing empirical data. For NMF, its components are ranked based only on the empirical FRV curves. The residual fractional eigenvalue plots, that is, \n  \n    \n      \n        1\n        −\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            k\n          \n        \n        \n          λ\n          \n            i\n          \n        \n        \n          \n            /\n          \n        \n        \n          ∑\n          \n            j\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          λ\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle 1-\\sum _{i=1}^{k}\\lambda _{i}{\\Big /}\\sum _{j=1}^{n}\\lambda _{j}}\n  \n as a function of component number \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n given a total of \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n components, for PCA have a flat plateau, where no data are captured to remove the quasi-static noise, then the curves drop quickly as an indication of over-fitting (random noise). The FRV curves for NMF is decreasing continuously when the NMF components are constructed sequentially, indicating the continuous capturing of quasi-static noise; then converge to higher levels than PCA, indicating the less over-fitting property of NMF.\n\n\n=== Iconography of correlations ===\nIt is often difficult to interpret the principal components when the data include many variables of various origins, or when some variables are qualitative. This leads the PCA user to a delicate elimination of several variables. If observations or variables have an excessive impact on the direction of the axes, they should be removed and then projected as supplementary elements. In addition, it is necessary to avoid interpreting the proximities between the points close to the center of the factorial plane.\n\nThe iconography of correlations, on the contrary, which is not a projection on a system of axes, does not have these drawbacks. We can therefore keep all the variables.\nThe principle of the diagram is to underline the \"remarkable\" correlations of the correlation matrix, by a solid line (positive correlation) or dotted line (negative correlation).\nA strong correlation is not \"remarkable\" if it is not direct, but caused by the effect of a third variable. Conversely, weak correlations can be \"remarkable\". For example, if a variable Y depends on several independent variables, the correlations of Y with each of them are weak and yet \"remarkable\".\n\n\n== Generalizations ==\n\n\n=== Sparse PCA ===\n\nA particular disadvantage of PCA is that the principal components are usually linear combinations of all input variables. Sparse PCA overcomes this disadvantage by finding linear combinations that contain just a few input variables. It extends the classic method of principal component analysis (PCA) for the reduction of dimensionality of data by adding sparsity constraint on the input variables.\nSeveral approaches have been proposed, including\n\na regression framework,\na convex relaxation/semidefinite programming framework,\na generalized power method framework\nan alternating maximization framework\nforward-backward greedy search and exact methods using branch-and-bound techniques,\nBayesian formulation framework.\nThe methodological and theoretical developments of Sparse PCA as well as its applications in scientific studies were recently reviewed in a survey paper.\n\n\n=== Nonlinear PCA ===\n\nMost of the modern methods for nonlinear dimensionality reduction find their theoretical and algorithmic roots in PCA or K-means. Pearson's original idea was to take a straight line (or plane) which will be \"the best fit\" to a set of data points. Trevor Hastie expanded on this concept by proposing Principal curves as the natural extension for the geometric interpretation of PCA, which explicitly constructs a manifold for data approximation followed by projecting the points onto it. See also the elastic map algorithm and principal geodesic analysis. Another popular generalization is kernel PCA, which corresponds to PCA performed in a reproducing kernel Hilbert space associated with a positive definite kernel.\nIn multilinear subspace learning, PCA is generalized to multilinear PCA (MPCA) that extracts features directly from tensor representations. MPCA is solved by performing PCA in each mode of the tensor iteratively. MPCA has been applied to face recognition, gait recognition, etc. MPCA is further extended to uncorrelated MPCA, non-negative MPCA and robust MPCA.\nN-way principal component analysis may be performed with models such as Tucker decomposition, PARAFAC, multiple factor analysis, co-inertia analysis, STATIS, and DISTATIS.\n\n\n=== Robust PCA ===\nWhile PCA finds the mathematically optimal method (as in minimizing the squared error), it is still sensitive to outliers in the data that produce large errors, something that the method tries to avoid in the first place. It is therefore common practice to remove outliers before computing PCA. However, in some contexts, outliers can be difficult to identify.\nFor example, in data mining algorithms like correlation clustering, the assignment of points to clusters and outliers is not known beforehand.\nA recently proposed generalization of PCA based on a weighted PCA increases robustness by assigning different weights to data objects based on their estimated relevancy.\nOutlier-resistant variants of PCA have also been proposed, based on L1-norm formulations (L1-PCA).\nRobust principal component analysis (RPCA) via decomposition in low-rank and sparse matrices is a modification of PCA that works well with respect to grossly corrupted observations.\n\n\n== Similar techniques ==\n\n\n=== Independent component analysis ===\nIndependent component analysis (ICA) is directed to similar problems as principal component analysis, but finds additively separable components rather than successive approximations.\n\n\n=== Network component analysis ===\nGiven a matrix \n  \n    \n      \n        E\n      \n    \n    {\\displaystyle E}\n  \n, it tries to decompose it into two matrices such that \n  \n    \n      \n        E\n        =\n        A\n        P\n      \n    \n    {\\displaystyle E=AP}\n  \n. A key difference from techniques such as PCA and ICA is that some of the entries of \n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n are constrained to be 0. Here \n  \n    \n      \n        P\n      \n    \n    {\\displaystyle P}\n  \n is termed the regulatory layer. While in general such a decomposition can have multiple solutions, they prove that if the following conditions are satisfied :\n\n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n has full column rank\nEach column of \n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n must have at least \n  \n    \n      \n        L\n        −\n        1\n      \n    \n    {\\displaystyle L-1}\n  \n zeroes where \n  \n    \n      \n        L\n      \n    \n    {\\displaystyle L}\n  \n is the number of columns of \n  \n    \n      \n        A\n      \n    \n    {\\displaystyle A}\n  \n (or alternatively the number of rows of \n  \n    \n      \n        P\n      \n    \n    {\\displaystyle P}\n  \n). The justification for this criterion is that if a node is removed from the regulatory layer along with all the output nodes connected to it, the result must still be characterized by a connectivity matrix with full column rank.\n\n  \n    \n      \n        P\n      \n    \n    {\\displaystyle P}\n  \n must have full row rank.\nthen the decomposition is unique up to multiplication by a scalar.\n\n\n=== Discriminant analysis of principal components ===\nDiscriminant analysis of principal components (DAPC) is a multivariate method used to identify and describe clusters of genetically related individuals. Genetic variation is partitioned into two components: variation between groups and within groups, and it maximizes the former. Linear discriminants are linear combinations of alleles which best separate the clusters. Alleles that most contribute to this discrimination are therefore those that are the most markedly different across groups. The contributions of alleles to the groupings identified by DAPC can allow identifying regions of the genome driving the genetic divergence among groups\nIn DAPC, data are first transformed using a principal components analysis (PCA) and subsequently clusters are identified using discriminant analysis (DA).\nA DAPC can be realized on R using the package Adegenet. (more info: adegenet on the web)\n\n\n=== Directional component analysis ===\nDirectional component analysis (DCA) is a method used in the atmospheric sciences for analysing multivariate datasets.\nLike PCA, it allows for dimension reduction, improved visualization and improved interpretability of large data-sets.\nAlso like PCA, it is based on a covariance matrix derived from the input dataset.\nThe difference between PCA and DCA is that DCA additionally requires the input of a vector direction, referred to as the impact. \nWhereas PCA maximises explained variance, DCA maximises probability density given impact.\nThe motivation for DCA is to find components of a multivariate dataset that are both likely (measured using probability density) and important (measured using the impact).\nDCA has been used to find the most likely and most serious heat-wave patterns in weather prediction ensembles\n, and the most likely and most impactful changes in rainfall due to climate change\n.\n\n\n== Software/source code ==\nALGLIB – a C++ and C# library that implements PCA and truncated PCA\nAnalytica – The built-in EigenDecomp function computes principal components.\nELKI – includes PCA for projection, including robust variants of PCA, as well as PCA-based clustering algorithms.\nGretl – principal component analysis can be performed either via the pca command or via the princomp() function.\nJulia – Supports PCA with the pca function in the MultivariateStats package.\nKNIME – A java based nodal arranging software for Analysis, in this the nodes called PCA, PCA compute, PCA Apply, PCA inverse make it easily.\nMaple (software) – The PCA command is used to perform a principal component analysis on a set of data.\nMathematica – Implements principal component analysis with the PrincipalComponents command using both covariance and correlation methods.\nMathPHP – PHP mathematics library with support for PCA.\nMATLAB – The SVD function is part of the basic system. In the Statistics Toolbox, the functions princomp and pca (R2012b) give the principal components, while the function pcares gives the residuals and reconstructed matrix for a low-rank PCA approximation.\nMatplotlib – a Python library that has a PCA package in the .mlab module.\nmlpack – Provides an implementation of principal component analysis in C++.\nmrmath – A high performance math library for Delphi and FreePascal can perform PCA; including robust variants.\nNAG Library – Principal components analysis is implemented via the g03aa routine (available in both the Fortran versions of the Library).\nNMath – Proprietary numerical library containing PCA for the .NET Framework.\nGNU Octave – Free software computational environment mostly compatible with MATLAB, the function princomp gives the principal component.\nOpenCV\nOracle Database 12c – Implemented via DBMS_DATA_MINING.SVDS_SCORING_MODE by specifying setting value SVDS_SCORING_PCA.\nOrange (software) – Integrates PCA in its visual programming environment. PCA displays a scree plot (degree of explained variance) where user can interactively select the number of principal components.\nOrigin – Contains PCA in its Pro version.\nQlucore – Commercial software for analyzing multivariate data with instant response using PCA.\nR – Free statistical package, the functions princomp and prcomp can be used for principal component analysis; prcomp uses singular value decomposition which generally gives better numerical accuracy. Some packages that implement PCA in R, include, but are not limited to: ade4, vegan, ExPosition, dimRed, and FactoMineR.\nSAS – Proprietary software; for example, see.\nscikit-learn – Python library for machine learning which contains PCA, Probabilistic PCA, Kernel PCA, Sparse PCA and other techniques in the decomposition module.\nScilab – Free and open-source, cross-platform numerical computational package, the function princomp computes principal component analysis, the function pca computes principal component analysis with standardized variables.\nSPSS – Proprietary software most commonly used by social scientists for PCA, factor analysis and associated cluster analysis.\nWeka – Java library for machine learning which contains modules for computing principal components.\n\n\n== See also ==\n\n\n== References ==\n\n\n== Further reading ==\nJackson, J.E. (1991). A User's Guide to Principal Components (Wiley).\nJolliffe, I. T. (1986). Principal Component Analysis. Springer Series in Statistics. Springer-Verlag. pp. 487. CiteSeerX 10.1.1.149.8828. doi:10.1007/b98835. ISBN 978-0-387-95442-4.\nJolliffe, I. T. (2002). Principal Component Analysis. Springer Series in Statistics. New York: Springer-Verlag. doi:10.1007/b98835. ISBN 978-0-387-95442-4.\nHusson François, Lê Sébastien & Pagès Jérôme (2009). Exploratory Multivariate Analysis by Example Using R. Chapman & Hall/CRC The R Series, London. 224p. ISBN 978-2-7535-0938-2\nPagès Jérôme (2014). Multiple Factor Analysis by Example Using R. Chapman & Hall/CRC The R Series London 272 p\n\n\n== External links ==\n\nUniversity of Copenhagen video by Rasmus Bro on YouTube\nStanford University video by Andrew Ng on YouTube\nA Tutorial on Principal Component Analysis\nA layman's introduction to principal component analysis on YouTube (a video of less than 100 seconds.)\nStatQuest: StatQuest: Principal Component Analysis (PCA), Step-by-Step on YouTube\nLayman's explanation in making sense of principal component analysis, eigenvectors & eigenvalues on Stack Overflow\nSee also the list of Software implementations"
}