{
  "id": "doc_019",
  "title": "K-means clustering",
  "url": "https://en.wikipedia.org/wiki/K-means_clustering",
  "topic": "K-means clustering",
  "content": "k-means clustering is a method of vector quantization, originally from signal processing, that aims to partition n observations into k clusters in which each observation belongs to the cluster with the nearest mean (cluster centers or cluster centroid). This results in a partitioning of the data space into Voronoi cells. k-means clustering minimizes within-cluster variances (squared Euclidean distances), but not regular Euclidean distances, which would be the more difficult Weber problem: the mean optimizes squared errors, whereas only the geometric median minimizes Euclidean distances. For instance, better Euclidean solutions can be found using k-medians and k-medoids.\nThe problem is computationally difficult (NP-hard); however, efficient heuristic algorithms converge quickly to a local optimum. These are usually similar to the expectation–maximization algorithm for mixtures of Gaussian distributions via an iterative refinement approach employed by both k-means and Gaussian mixture modeling. They both use cluster centers to model the data; however, k-means clustering tends to find clusters of comparable spatial extent, while the Gaussian mixture model allows clusters to have different shapes.\nThe unsupervised k-means algorithm has a loose relationship to the k-nearest neighbor classifier, a popular supervised machine learning technique for classification that is often confused with k-means due to the name. Applying the 1-nearest neighbor classifier to the cluster centers obtained by k-means classifies new data into the existing clusters. This is known as nearest centroid classifier or Rocchio algorithm.\n\n\n== Description ==\nGiven a set of observations (x1, x2, ..., xn), where each observation is a \n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n-dimensional real vector, k-means clustering aims to partition the n observations into k (≤ n) sets S = {S1, S2, ..., Sk} so as to minimize the within-cluster sum of squares (WCSS) (i.e. variance). Formally, the objective is to find:\n\n  \n    \n      \n        \n          \n            \n              a\n              r\n              g\n              \n              m\n              i\n              n\n            \n          \n          \n            \n              S\n            \n          \n        \n        ⁡\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            k\n          \n        \n        \n          ∑\n          \n            \n              x\n            \n            ∈\n            \n              S\n              \n                i\n              \n            \n          \n        \n        \n          \n            ‖\n            \n              \n                x\n              \n              −\n              \n                \n                  μ\n                \n                \n                  i\n                \n              \n            \n            ‖\n          \n          \n            2\n          \n        \n        =\n        \n          \n            \n              a\n              r\n              g\n              \n              m\n              i\n              n\n            \n          \n          \n            \n              S\n            \n          \n        \n        ⁡\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            k\n          \n        \n        \n          |\n        \n        \n          S\n          \n            i\n          \n        \n        \n          |\n        \n        Var\n        ⁡\n        \n          S\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle \\mathop {\\operatorname {arg\\,min} } _{\\mathbf {S} }\\sum _{i=1}^{k}\\sum _{\\mathbf {x} \\in S_{i}}\\left\\|\\mathbf {x} -{\\boldsymbol {\\mu }}_{i}\\right\\|^{2}=\\mathop {\\operatorname {arg\\,min} } _{\\mathbf {S} }\\sum _{i=1}^{k}|S_{i}|\\operatorname {Var} S_{i}}\n  \n\nwhere μi is the mean (also called centroid) of points in \n  \n    \n      \n        \n          S\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle S_{i}}\n  \n, i.e.\n\n  \n    \n      \n        \n          \n            μ\n            \n              i\n            \n          \n        \n        =\n        \n          \n            1\n            \n              \n                |\n              \n              \n                S\n                \n                  i\n                \n              \n              \n                |\n              \n            \n          \n        \n        \n          ∑\n          \n            \n              x\n            \n            ∈\n            \n              S\n              \n                i\n              \n            \n          \n        \n        \n          x\n        \n        ,\n      \n    \n    {\\displaystyle {\\boldsymbol {\\mu _{i}}}={\\frac {1}{|S_{i}|}}\\sum _{\\mathbf {x} \\in S_{i}}\\mathbf {x} ,}\n  \n\n  \n    \n      \n        \n          |\n        \n        \n          S\n          \n            i\n          \n        \n        \n          |\n        \n      \n    \n    {\\displaystyle |S_{i}|}\n  \n is the size of \n  \n    \n      \n        \n          S\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle S_{i}}\n  \n, and \n  \n    \n      \n        ‖\n        ⋅\n        ‖\n      \n    \n    {\\displaystyle \\|\\cdot \\|}\n  \n is the usual L2 norm . This is equivalent to minimizing the pairwise squared deviations of points in the same cluster:\n\n  \n    \n      \n        \n          \n            \n              a\n              r\n              g\n              \n              m\n              i\n              n\n            \n          \n          \n            \n              S\n            \n          \n        \n        ⁡\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            k\n          \n        \n        \n        \n          \n            1\n            \n              \n                |\n              \n              \n                S\n                \n                  i\n                \n              \n              \n                |\n              \n            \n          \n        \n        \n        \n          ∑\n          \n            \n              x\n            \n            ,\n            \n              y\n            \n            ∈\n            \n              S\n              \n                i\n              \n            \n          \n        \n        \n          \n            ‖\n            \n              \n                x\n              \n              −\n              \n                y\n              \n            \n            ‖\n          \n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\mathop {\\operatorname {arg\\,min} } _{\\mathbf {S} }\\sum _{i=1}^{k}\\,{\\frac {1}{|S_{i}|}}\\,\\sum _{\\mathbf {x} ,\\mathbf {y} \\in S_{i}}\\left\\|\\mathbf {x} -\\mathbf {y} \\right\\|^{2}}\n  \n\nThe equivalence can be deduced from the identity \n  \n    \n      \n        \n          |\n        \n        \n          S\n          \n            i\n          \n        \n        \n          |\n        \n        \n          ∑\n          \n            \n              x\n            \n            ∈\n            \n              S\n              \n                i\n              \n            \n          \n        \n        \n          \n            ‖\n            \n              \n                x\n              \n              −\n              \n                \n                  μ\n                \n                \n                  i\n                \n              \n            \n            ‖\n          \n          \n            2\n          \n        \n        =\n        \n          \n            1\n            2\n          \n        \n        \n          ∑\n          \n            \n              x\n            \n            ,\n            \n              y\n            \n            ∈\n            \n              S\n              \n                i\n              \n            \n          \n        \n        \n          \n            ‖\n            \n              \n                x\n              \n              −\n              \n                y\n              \n            \n            ‖\n          \n          \n            2\n          \n        \n      \n    \n    {\\textstyle |S_{i}|\\sum _{\\mathbf {x} \\in S_{i}}\\left\\|\\mathbf {x} -{\\boldsymbol {\\mu }}_{i}\\right\\|^{2}={\\frac {1}{2}}\\sum _{\\mathbf {x} ,\\mathbf {y} \\in S_{i}}\\left\\|\\mathbf {x} -\\mathbf {y} \\right\\|^{2}}\n  \n. Since the total variance is constant, this is equivalent to maximizing the sum of squared deviations between points in different clusters (between-cluster sum of squares, BCSS). This deterministic relationship is also related to the law of total variance in probability theory.\n\n\n== History ==\nThe term \"k-means\" was first used by James MacQueen in 1967, though the idea goes back to Hugo Steinhaus in 1956. The standard algorithm was first proposed by Stuart Lloyd of Bell Labs in 1957 as a technique for pulse-code modulation, although it was not published as a journal article until 1982. In 1965, Edward W. Forgy published essentially the same method, which is why it is sometimes referred to as the Lloyd–Forgy algorithm.\n\n\n== Algorithms ==\n\n\n=== Standard algorithm (naive k-means) ===\n\nThe most common algorithm uses an iterative refinement technique. Due to its ubiquity, it is often called \"the k-means algorithm\"; it is also referred to as Lloyd's algorithm, particularly in the computer science community. It is sometimes also referred to as \"naïve k-means\", because there exist much faster alternatives.\nGiven an initial set of k means m1(1), ..., mk(1) (see below), the algorithm proceeds by alternating between two steps:\n\nAssignment step: Assign each observation to the cluster with the nearest mean (centroid): that with the least squared Euclidean distance. (Mathematically, this means partitioning the observations according to the Voronoi diagram generated by the means.) \n  \n    \n      \n        \n          S\n          \n            i\n          \n          \n            (\n            t\n            )\n          \n        \n        =\n        \n          {\n          \n            \n              x\n              \n                p\n              \n            \n            :\n            \n              \n                ‖\n                \n                  \n                    x\n                    \n                      p\n                    \n                  \n                  −\n                  \n                    m\n                    \n                      i\n                    \n                    \n                      (\n                      t\n                      )\n                    \n                  \n                \n                ‖\n              \n              \n                2\n              \n            \n            ≤\n            \n              \n                ‖\n                \n                  \n                    x\n                    \n                      p\n                    \n                  \n                  −\n                  \n                    m\n                    \n                      j\n                    \n                    \n                      (\n                      t\n                      )\n                    \n                  \n                \n                ‖\n              \n              \n                2\n              \n            \n             \n            ∀\n            j\n            ,\n            1\n            ≤\n            j\n            ≤\n            k\n          \n          }\n        \n        ,\n      \n    \n    {\\displaystyle S_{i}^{(t)}=\\left\\{x_{p}:\\left\\|x_{p}-m_{i}^{(t)}\\right\\|^{2}\\leq \\left\\|x_{p}-m_{j}^{(t)}\\right\\|^{2}\\ \\forall j,1\\leq j\\leq k\\right\\},}\n  \n where each \n  \n    \n      \n        \n          x\n          \n            p\n          \n        \n      \n    \n    {\\displaystyle x_{p}}\n  \n is assigned to exactly one \n  \n    \n      \n        \n          S\n          \n            (\n            t\n            )\n          \n        \n      \n    \n    {\\displaystyle S^{(t)}}\n  \n, even if it could be assigned to two or more of them.\nUpdate step: Recalculate means (centroids) for observations assigned to each cluster. This is also called refitting. \n  \n    \n      \n        \n          m\n          \n            i\n          \n          \n            (\n            t\n            +\n            1\n            )\n          \n        \n        =\n        \n          \n            1\n            \n              |\n              \n                S\n                \n                  i\n                \n                \n                  (\n                  t\n                  )\n                \n              \n              |\n            \n          \n        \n        \n          ∑\n          \n            \n              x\n              \n                j\n              \n            \n            ∈\n            \n              S\n              \n                i\n              \n              \n                (\n                t\n                )\n              \n            \n          \n        \n        \n          x\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle m_{i}^{(t+1)}={\\frac {1}{\\left|S_{i}^{(t)}\\right|}}\\sum _{x_{j}\\in S_{i}^{(t)}}x_{j}}\n  \n\nThe objective function in k-means is the WCSS (within cluster sum of squares). After each iteration, the WCSS monotonically decreases, giving a nonnegative monotonically decreasing sequence. This guarantees that the k-means always converges, but not necessarily to the global optimum.\nThe algorithm has converged when the assignments no longer change or equivalently, when the WCSS has become stable. The algorithm is not guaranteed to find the optimal cluster assignment.\nThe algorithm is often presented as assigning objects to the nearest cluster by distance. Using a different distance function other than (squared) Euclidean distance may prevent the algorithm from converging. Various modifications of k-means such as spherical k-means and k-medoids have been proposed to allow using other distance measures.\n\nPseudocode\nThe below pseudocode outlines the implementation of the standard k-means clustering algorithm. Initialization of centroids, distance metric between points and centroids, and the calculation of new centroids are design choices and will vary with different implementations. In this example pseudocode, distance() returns the distance between the specified points.\n\nfunction kmeans(k, points) is\n    // Initialize centroids\n    centroids ← list of k starting centroids\n    converged ← false\n\n    while converged == false do\n        // Create empty clusters\n        clusters ← list of k empty lists\n\n        // Assign each point to the nearest centroid\n        for i ← 0 to length(points) - 1 do\n            point ← points[i]\n            closestIndex ← 0\n            minDistance ← distance(point, centroids[0])\n            for j ← 1 to k - 1 do\n                d ← distance(point, centroids[j])\n                if d < minDistance THEN\n                    minDistance ← d\n                    closestIndex ← j\n            clusters[closestIndex].append(point)\n\n        // Recalculate centroids as the mean of each cluster\n        newCentroids ← empty list\n        for i ← 0 to k - 1 do\n            newCentroid ← calculateCentroid(clusters[i])\n            newCentroids.append(newCentroid)\n\n        // Check for convergence\n        if newCentroids == centroids THEN\n            converged ← true\n        else\n            centroids ← newCentroids\n\n    return clusters\n\n\n==== Initialization methods ====\nCommonly used initialization methods are Forgy and Random Partition. The Forgy method randomly chooses k observations from the dataset and uses these as the initial means. The Random Partition method first randomly assigns a cluster to each observation and then proceeds to the update step, thus computing the initial mean to be the centroid of the cluster's randomly assigned points. The Forgy method tends to spread the initial means out, while Random Partition places all of them close to the center of the data set. According to Hamerly et al., the Random Partition method is generally preferable for algorithms such as the k-harmonic means and fuzzy k-means. For expectation maximization and standard k-means algorithms, the Forgy method of initialization is preferable. A comprehensive study by Celebi et al., however, found that popular initialization methods such as Forgy, Random Partition, and Maximin often perform poorly, whereas Bradley and Fayyad's approach performs \"consistently\" in \"the best group\" and k-means++ performs \"generally well\".\n\nThe algorithm does not guarantee convergence to the global optimum. The result may depend on the initial clusters. As the algorithm is usually fast, it is common to run it multiple times with different starting conditions. However, worst-case performance can be slow: in particular certain point sets, even in two dimensions, converge in exponential time, that is 2Ω(n). These point sets do not seem to arise in practice: this is corroborated by the fact that the smoothed running time of k-means is polynomial.\nThe \"assignment\" step is referred to as the \"expectation step\", while the \"update step\" is a maximization step, making this algorithm a variant of the generalized expectation–maximization algorithm.\n\n\n=== Complexity ===\nFinding the optimal solution to the k-means clustering problem for observations in d dimensions is:\n\nNP-hard in general Euclidean space (of d dimensions) even for two clusters,\nNP-hard for a general number of clusters k even in the plane,\nif k and d (the dimension) are fixed, the problem can be exactly solved in time \n  \n    \n      \n        O\n        (\n        \n          n\n          \n            d\n            k\n            +\n            1\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{dk+1})}\n  \n, where n is the number of entities to be clustered.\nThus, a variety of heuristic algorithms such as Lloyd's algorithm given above are generally used.\nThe running time of Lloyd's algorithm (and most variants) is \n  \n    \n      \n        O\n        (\n        n\n        k\n        d\n        i\n        )\n      \n    \n    {\\displaystyle O(nkdi)}\n  \n, where:\n\nn is the number of d-dimensional vectors (to be clustered)\nk the number of clusters\ni the number of iterations needed until convergence.\nOn data that does have a clustering structure, the number of iterations until convergence is often small, and results only improve slightly after the first dozen iterations. Lloyd's algorithm is therefore often considered to be of \"linear\" complexity in practice, although it is in the worst case superpolynomial when performed until convergence.\n\nIn the worst-case, Lloyd's algorithm needs \n  \n    \n      \n        i\n        =\n        \n          2\n          \n            Ω\n            (\n            \n              \n                n\n              \n            \n            )\n          \n        \n      \n    \n    {\\displaystyle i=2^{\\Omega ({\\sqrt {n}})}}\n  \n iterations, so that the worst-case complexity of Lloyd's algorithm is superpolynomial.\nLloyd's k-means algorithm has polynomial smoothed running time. It is shown that for arbitrary set of n points in \n  \n    \n      \n        [\n        0\n        ,\n        1\n        \n          ]\n          \n            d\n          \n        \n      \n    \n    {\\displaystyle [0,1]^{d}}\n  \n, if each point is independently perturbed by a normal distribution with mean 0 and variance \n  \n    \n      \n        \n          σ\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\sigma ^{2}}\n  \n, then the expected running time of k-means algorithm is bounded by \n  \n    \n      \n        O\n        (\n        \n          n\n          \n            34\n          \n        \n        \n          k\n          \n            34\n          \n        \n        \n          d\n          \n            8\n          \n        \n        \n          log\n          \n            4\n          \n        \n        ⁡\n        (\n        n\n        )\n        \n          /\n        \n        \n          σ\n          \n            6\n          \n        \n        )\n      \n    \n    {\\displaystyle O(n^{34}k^{34}d^{8}\\log ^{4}(n)/\\sigma ^{6})}\n  \n, which is a polynomial in n, k, d and \n  \n    \n      \n        1\n        \n          /\n        \n        σ\n      \n    \n    {\\displaystyle 1/\\sigma }\n  \n.\nBetter bounds are proven for simple cases. For example, it is shown that the running time of k-means algorithm is bounded by \n  \n    \n      \n        O\n        (\n        d\n        \n          n\n          \n            4\n          \n        \n        \n          M\n          \n            2\n          \n        \n        )\n      \n    \n    {\\displaystyle O(dn^{4}M^{2})}\n  \n for n points in an integer lattice \n  \n    \n      \n        {\n        1\n        ,\n        …\n        ,\n        M\n        \n          }\n          \n            d\n          \n        \n      \n    \n    {\\displaystyle \\{1,\\dots ,M\\}^{d}}\n  \n.\nLloyd's algorithm is the standard approach for this problem. However, it spends a lot of processing time computing the distances between each of the k cluster centers and the n data points. Since points usually stay in the same clusters after a few iterations, much of this work is unnecessary, making the naïve implementation very inefficient. Some implementations use caching and the triangle inequality in order to create bounds and accelerate Lloyd's algorithm.\n\n\n=== Optimal number of clusters ===\n\nFinding the optimal number of clusters (k) for k-means clustering is a crucial step to ensure that the clustering results are meaningful and useful. Several techniques are available to determine a suitable number of clusters. Here are some of commonly used methods:\n\nElbow method (clustering): This method involves plotting the explained variation as a function of the number of clusters, and picking the elbow of the curve as the number of clusters to use. However, the notion of an \"elbow\" is not well-defined and this is known to be unreliable.\nSilhouette (clustering): Silhouette analysis measures the quality of clustering and provides an insight into the separation distance between the resulting clusters. A higher silhouette score indicates that the object is well matched to its own cluster and poorly matched to neighboring clusters.\nGap statistic: The Gap Statistic compares the total within intra-cluster variation for different values of k with their expected values under null reference distribution of the data. The optimal k is the value that yields the largest gap statistic.\nDavies–Bouldin index: The Davies-Bouldin index is a measure of the how much separation there is between clusters. Lower values of the Davies-Bouldin index indicate a model with better separation.\nCalinski-Harabasz index: This Index evaluates clusters based on their compactness and separation. The index is calculated using the ratio of between-cluster variance to within-cluster variance, with higher values indicate better-defined clusters.\nRand index: It calculates the proportion of agreement between the two clusters, considering both the pairs of elements that are correctly assigned to the same or different clusters. Higher values indicate greater similarity and better clustering quality. To provide a more accurate measure, the Adjusted Rand Index (ARI), introduced by Hubert and Arabie in 1985, corrects the Rand Index by adjusting for the expected similarity of all pairings due to chance.\n\n\n=== Variations ===\nJenks natural breaks optimization: k-means applied to univariate data\nk-medians clustering uses the median in each dimension instead of the mean, and this way minimizes \n  \n    \n      \n        \n          L\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle L_{1}}\n  \n norm (Taxicab geometry).\nk-medoids (also: Partitioning Around Medoids, PAM) uses the medoid instead of the mean, and this way minimizes the sum of distances for arbitrary distance functions.\nFuzzy C-Means Clustering is a soft version of k-means, where each data point has a fuzzy degree of belonging to each cluster.\nGaussian mixture models trained with expectation–maximization algorithm (EM algorithm) maintains probabilistic assignments to clusters, instead of deterministic assignments, and multivariate Gaussian distributions instead of means.\nk-means++ chooses initial centers in a way that gives a provable upper bound on the WCSS objective.\nThe filtering algorithm uses k-d trees to speed up each k-means step.\nSome methods attempt to speed up each k-means step using the triangle inequality.\nEscape local optima by swapping points between clusters.\nThe Spherical k-means clustering algorithm is suitable for textual data.\nHierarchical variants such as Bisecting k-means, X-means clustering and G-means clustering repeatedly split clusters to build a hierarchy, and can also try to automatically determine the optimal number of clusters in a dataset.\nInternal cluster evaluation measures such as cluster silhouette can be helpful at determining the number of clusters.\nMinkowski weighted k-means automatically calculates cluster specific feature weights, supporting the intuitive idea that a feature may have different degrees of relevance at different features. These weights can also be used to re-scale a given data set, increasing the likelihood of a cluster validity index to be optimized at the expected number of clusters.\nMini-batch k-means: k-means variation using \"mini batch\" samples for data sets that do not fit into memory.\nOtsu's method\n\n\n=== Hartigan–Wong method ===\nHartigan and Wong's method provides a variation of k-means algorithm which progresses towards a local minimum of the minimum sum-of-squares problem with different solution updates. The method is a local search that iteratively attempts to relocate a sample into a different cluster as long as this process improves the objective function. When no sample can be relocated into a different cluster with an improvement of the objective, the method stops (in a local minimum). In a similar way as the classical k-means, the approach remains a heuristic since it does not necessarily guarantee that the final solution is globally optimum.\nLet \n  \n    \n      \n        φ\n        (\n        \n          S\n          \n            j\n          \n        \n        )\n      \n    \n    {\\displaystyle \\varphi (S_{j})}\n  \n be the individual cost of \n  \n    \n      \n        \n          S\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle S_{j}}\n  \n defined by \n  \n    \n      \n        \n          ∑\n          \n            x\n            ∈\n            \n              S\n              \n                j\n              \n            \n          \n        \n        (\n        x\n        −\n        \n          μ\n          \n            j\n          \n        \n        \n          )\n          \n            2\n          \n        \n      \n    \n    {\\textstyle \\sum _{x\\in S_{j}}(x-\\mu _{j})^{2}}\n  \n, with \n  \n    \n      \n        \n          μ\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle \\mu _{j}}\n  \n the center of the cluster.\n\nAssignment step\nHartigan and Wong's method starts by partitioning the points into random clusters \n  \n    \n      \n        {\n        \n          S\n          \n            j\n          \n        \n        \n          }\n          \n            j\n            ∈\n            {\n            1\n            ,\n            ⋯\n            k\n            }\n          \n        \n      \n    \n    {\\displaystyle \\{S_{j}\\}_{j\\in \\{1,\\cdots k\\}}}\n  \n.\nUpdate step\nNext it determines the \n  \n    \n      \n        n\n        ,\n        m\n        ∈\n        {\n        1\n        ,\n        …\n        ,\n        k\n        }\n      \n    \n    {\\displaystyle n,m\\in \\{1,\\ldots ,k\\}}\n  \n and \n  \n    \n      \n        x\n        ∈\n        \n          S\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle x\\in S_{n}}\n  \n for which the following function reaches a maximum \n  \n    \n      \n        Δ\n        (\n        m\n        ,\n        n\n        ,\n        x\n        )\n        =\n        φ\n        (\n        \n          S\n          \n            n\n          \n        \n        )\n        +\n        φ\n        (\n        \n          S\n          \n            m\n          \n        \n        )\n        −\n        φ\n        (\n        \n          S\n          \n            n\n          \n        \n        ∖\n        {\n        x\n        }\n        )\n        −\n        φ\n        (\n        \n          S\n          \n            m\n          \n        \n        ∪\n        {\n        x\n        }\n        )\n        .\n      \n    \n    {\\displaystyle \\Delta (m,n,x)=\\varphi (S_{n})+\\varphi (S_{m})-\\varphi (S_{n}\\setminus \\{x\\})-\\varphi (S_{m}\\cup \\{x\\}).}\n  \n For the \n  \n    \n      \n        x\n        ,\n        n\n        ,\n        m\n      \n    \n    {\\displaystyle x,n,m}\n  \n that reach this maximum, \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n moves from the cluster \n  \n    \n      \n        \n          S\n          \n            n\n          \n        \n      \n    \n    {\\displaystyle S_{n}}\n  \n to the cluster \n  \n    \n      \n        \n          S\n          \n            m\n          \n        \n      \n    \n    {\\displaystyle S_{m}}\n  \n.\nTermination\nThe algorithm terminates once \n  \n    \n      \n        Δ\n        (\n        m\n        ,\n        n\n        ,\n        x\n        )\n      \n    \n    {\\displaystyle \\Delta (m,n,x)}\n  \n is less than zero for all \n  \n    \n      \n        x\n        ,\n        n\n        ,\n        m\n      \n    \n    {\\displaystyle x,n,m}\n  \n.\nDifferent move acceptance strategies can be used. In a first-improvement strategy, any improving relocation can be applied, whereas in a best-improvement strategy, all possible relocations are iteratively tested and only the best is applied at each iteration. The former approach favors speed, whether the latter approach generally favors solution quality at the expense of additional computational time. The function \n  \n    \n      \n        Δ\n      \n    \n    {\\displaystyle \\Delta }\n  \n used to calculate the result of a relocation can also be efficiently evaluated by using equality\n\n  \n    \n      \n        Δ\n        (\n        x\n        ,\n        n\n        ,\n        m\n        )\n        =\n        \n          \n            \n              ∣\n              \n                S\n                \n                  n\n                \n              \n              ∣\n            \n            \n              ∣\n              \n                S\n                \n                  n\n                \n              \n              ∣\n              −\n              1\n            \n          \n        \n        ⋅\n        ‖\n        \n          μ\n          \n            n\n          \n        \n        −\n        x\n        \n          ‖\n          \n            2\n          \n        \n        −\n        \n          \n            \n              ∣\n              \n                S\n                \n                  m\n                \n              \n              ∣\n            \n            \n              ∣\n              \n                S\n                \n                  m\n                \n              \n              ∣\n              +\n              1\n            \n          \n        \n        ⋅\n        ‖\n        \n          μ\n          \n            m\n          \n        \n        −\n        x\n        \n          ‖\n          \n            2\n          \n        \n        .\n      \n    \n    {\\displaystyle \\Delta (x,n,m)={\\frac {\\mid S_{n}\\mid }{\\mid S_{n}\\mid -1}}\\cdot \\lVert \\mu _{n}-x\\rVert ^{2}-{\\frac {\\mid S_{m}\\mid }{\\mid S_{m}\\mid +1}}\\cdot \\lVert \\mu _{m}-x\\rVert ^{2}.}\n  \n\n\n=== Global optimization and meta-heuristics ===\nThe classical k-means algorithm and its variations are known to only converge to local minima of the minimum-sum-of-squares clustering problem defined as\n\n  \n    \n      \n        \n          \n            \n              a\n              r\n              g\n              \n              m\n              i\n              n\n            \n          \n          \n            \n              S\n            \n          \n        \n        ⁡\n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            k\n          \n        \n        \n          ∑\n          \n            \n              x\n            \n            ∈\n            \n              S\n              \n                i\n              \n            \n          \n        \n        \n          \n            ‖\n            \n              \n                x\n              \n              −\n              \n                \n                  μ\n                \n                \n                  i\n                \n              \n            \n            ‖\n          \n          \n            2\n          \n        \n        .\n      \n    \n    {\\displaystyle \\mathop {\\operatorname {arg\\,min} } _{\\mathbf {S} }\\sum _{i=1}^{k}\\sum _{\\mathbf {x} \\in S_{i}}\\left\\|\\mathbf {x} -{\\boldsymbol {\\mu }}_{i}\\right\\|^{2}.}\n  \n\nMany studies have attempted to improve the convergence behavior of the algorithm and maximize the chances of attaining the global optimum (or at least, local minima of better quality). Initialization and restart techniques discussed in the previous sections are one alternative to find better solutions. More recently, global optimization algorithms based on branch-and-bound and semidefinite programming have produced ‘’provenly optimal’’ solutions for datasets with up to 4,177 entities and 20,531 features. As expected, due to the NP-hardness of the subjacent optimization problem, the computational time of optimal algorithms for k-means quickly increases beyond this size. Optimal solutions for small- and medium-scale still remain valuable as a benchmark tool, to evaluate the quality of other heuristics. To find high-quality local minima within a controlled computational time but without optimality guarantees, other works have explored metaheuristics and other global optimization techniques, e.g., based on incremental approaches and convex optimization, random swaps (i.e., iterated local search), variable neighborhood search and genetic algorithms. It is indeed known that finding better local minima of the minimum sum-of-squares clustering problem can make the difference between failure and success to recover cluster structures in feature spaces of high dimension.\n\n\n== Discussion ==\n\nThree key features of k-means that make it efficient are often regarded as its biggest drawbacks:\n\nEuclidean distance is used as a metric and variance is used as a measure of cluster scatter.\nThe number of clusters k is an input parameter: an inappropriate choice of k may yield poor results. That is why, when performing k-means, it is important to run diagnostic checks for determining the number of clusters in the data set.\nConvergence to a local minimum may produce counterintuitive (\"wrong\") results (see example in Fig.).\nA key limitation of k-means is its cluster model. The concept is based on spherical clusters that are separable so that the mean converges towards the cluster center. The clusters are expected to be of similar size, so that the assignment to the nearest cluster center is the correct assignment. When for example applying k-means with a value of \n  \n    \n      \n        k\n        =\n        3\n      \n    \n    {\\displaystyle k=3}\n  \n onto the well-known Iris flower data set, the result often fails to separate the three Iris species contained in the data set. With \n  \n    \n      \n        k\n        =\n        2\n      \n    \n    {\\displaystyle k=2}\n  \n, the two visible clusters (one containing two species) will be discovered, whereas with \n  \n    \n      \n        k\n        =\n        3\n      \n    \n    {\\displaystyle k=3}\n  \n one of the two clusters will be split into two even parts. In fact, \n  \n    \n      \n        k\n        =\n        2\n      \n    \n    {\\displaystyle k=2}\n  \n is more appropriate for this data set, despite the data set's containing 3 classes. As with any other clustering algorithm, the k-means result makes assumptions that the data satisfy certain criteria. It works well on some data sets, and fails on others.\nThe result of k-means can be seen as the Voronoi cells of the cluster means. Since data is split halfway between cluster means, this can lead to suboptimal splits as can be seen in the \"mouse\" example. The Gaussian models used by the expectation–maximization algorithm (arguably a generalization of k-means) are more flexible by having both variances and covariances. The EM result is thus able to accommodate clusters of variable size much better than k-means as well as correlated clusters (not in this example). In counterpart, EM requires the optimization of a larger number of free parameters and poses some methodological issues due to vanishing clusters or badly-conditioned covariance matrices. k-means is closely related to nonparametric Bayesian modeling.\n\n\n== Applications ==\nk-means clustering is rather easy to apply to even large data sets, particularly when using heuristics such as Lloyd's algorithm. It has been successfully used in market segmentation, computer vision, and astronomy among many other domains. It often is used as a preprocessing step for other algorithms, for example to find a starting configuration.\n\n\n=== Vector quantization ===\n\nVector quantization, a technique commonly used in signal processing and computer graphics, involves reducing the color palette of an image to a fixed number of colors, known as k. One popular method for achieving vector quantization is through k-means clustering. In this process, k-means is applied to the color space of an image to partition it into k clusters, with each cluster representing a distinct color in the image. This technique is particularly useful in image segmentation tasks, where it helps identify and group similar colors together.\n\nExample: In the field of computer graphics, k-means clustering is often employed for color quantization in image compression. By reducing the number of colors used to represent an image, file sizes can be significantly reduced without significant loss of visual quality. For instance, consider an image with millions of colors. By applying k-means clustering with k set to a smaller number, the image can be represented using a more limited color palette, resulting in a compressed version that consumes less storage space and bandwidth. Other uses of vector quantization include non-random sampling, as k-means can easily be used to choose k different but prototypical objects from a large data set for further analysis.\n\n\n=== Cluster analysis ===\n\nCluster analysis, a fundamental task in data mining and machine learning, involves grouping a set of data points into clusters based on their similarity. k-means clustering is a popular algorithm used for partitioning data into k clusters, where each cluster is represented by its centroid.\nHowever, the pure k-means algorithm is not very flexible, and as such is of limited use (except for when vector quantization as above is actually the desired use case). In particular, the parameter k is known to be hard to choose (as discussed above) when not given by external constraints. Another limitation is that it cannot be used with arbitrary distance functions or on non-numerical data. For these use cases, many other algorithms are superior.\nExample: In marketing, k-means clustering is frequently employed for market segmentation, where customers with similar characteristics or behaviors are grouped together. For instance, a retail company may use k-means clustering to segment its customer base into distinct groups based on factors such as purchasing behavior, demographics, and geographic location. These customer segments can then be targeted with tailored marketing strategies and product offerings to maximize sales and customer satisfaction.\n\n\n=== Feature learning ===\n\nk-means clustering has been used as a feature learning (or dictionary learning) step, in either (semi-)supervised learning or unsupervised learning. The basic approach is first to train a k-means clustering representation, using the input training data (which need not be labelled). Then, to project any input datum into the new feature space, an \"encoding\" function, such as the thresholded matrix-product of the datum with the centroid locations, computes the distance from the datum to each centroid, or simply an indicator function for the nearest centroid, or some smooth transformation of the distance. Alternatively, transforming the sample-cluster distance through a Gaussian RBF, obtains the hidden layer of a radial basis function network.\nThis use of k-means has been successfully combined with simple, linear classifiers for semi-supervised learning in NLP (specifically for named-entity recognition) and in computer vision. On an object recognition task, it was found to exhibit comparable performance with more sophisticated feature learning approaches such as autoencoders and restricted Boltzmann machines. However, it generally requires more data, for equivalent performance, because each data point only contributes to one \"feature\".\nExample: In natural language processing (NLP), k-means clustering has been integrated with simple linear classifiers for semi-supervised learning tasks such as named-entity recognition (NER). By first clustering unlabeled text data using k-means, meaningful features can be extracted to improve the performance of NER models. For instance, k-means clustering can be applied to identify clusters of words or phrases that frequently co-occur in the input text, which can then be used as features for training the NER model. This approach has been shown to achieve comparable performance with more complex feature learning techniques such as autoencoders and restricted Boltzmann machines, albeit with a greater requirement for labeled data.\n\n\n=== Recent Developments ===\nRecent advancements in the application of k-means clustering include improvements in initialization techniques, such as the use of k-means++ initialization to select initial cluster centroids in a more effective manner. Additionally, researchers have explored the integration of k-means clustering with deep learning methods, such as convolutional neural networks (CNNs) and recurrent neural networks (RNNs), to enhance the performance of various tasks in computer vision, natural language processing, and other domains.\n\n\n== Relation to other algorithms ==\n\n\n=== Gaussian mixture model ===\n\nThe slow \"standard algorithm\" for k-means clustering, and its associated expectation–maximization algorithm, is a special case of a Gaussian mixture model, specifically, the limiting case when fixing all covariances to be diagonal, equal and have infinitesimal small variance. Instead of small variances, a hard cluster assignment can also be used to show another equivalence of k-means clustering to a special case of \"hard\" Gaussian mixture modelling. This does not mean that it is efficient to use Gaussian mixture modelling to compute k-means, but just that there is a theoretical relationship, and that Gaussian mixture modelling can be interpreted as a generalization of k-means; on the contrary, it has been suggested to use k-means clustering to find starting points for Gaussian mixture modelling on difficult data.\n\n\n=== k-SVD ===\n\nAnother generalization of the k-means algorithm is the k-SVD algorithm, which estimates data points as a sparse linear combination of \"codebook vectors\". k-means corresponds to the special case of using a single codebook vector, with a weight of 1.\n\n\n=== Principal component analysis ===\n\nThe relaxed solution of k-means clustering, specified by the cluster indicators, is given by principal component analysis (PCA).  The intuition is that k-means describe spherically shaped (ball-like) clusters. If the data has 2 clusters, the line connecting the two centroids is the best 1-dimensional projection direction, which is also the first PCA direction. Cutting the line at the center of mass separates the clusters (this is the continuous relaxation of the discrete cluster indicator). If the data have three clusters, the 2-dimensional plane spanned by three cluster centroids is the best 2-D projection. This plane is also defined by the first two PCA dimensions. Well-separated clusters are effectively modelled by ball-shaped clusters and thus discovered by k-means. Non-ball-shaped clusters are hard to separate when they are close. For example, two half-moon shaped clusters intertwined in space do not separate well when projected onto PCA subspace. k-means should not be expected to do well on this data. It is straightforward to produce counterexamples to the statement that the cluster centroid subspace is spanned by the principal directions.\n\n\n=== Mean shift clustering ===\n\nBasic mean shift clustering algorithms maintain a set of data points the same size as the input data set. Initially, this set is copied from the input set. All points are then iteratively moved towards the mean of the points surrounding them. By contrast, k-means restricts the set of clusters to k clusters, usually much less than the number of points in the input data set, using the mean of all points in the prior cluster that are closer to that point than any other for the centroid (e.g. within the Voronoi partition of each updating point). A mean shift algorithm that is similar then to k-means, called likelihood mean shift, replaces the set of points undergoing replacement by the mean of all points in the input set that are within a given distance of the changing set. An advantage of mean shift clustering over k-means is the detection of an arbitrary number of clusters in the data set, as there is not a parameter determining the number of clusters. Mean shift can be much slower than k-means, and still requires selection of a bandwidth parameter.\n\n\n=== Independent component analysis ===\n\nUnder sparsity assumptions and when input data is pre-processed with the whitening transformation, k-means produces the solution to the linear independent component analysis (ICA) task. This aids in explaining the successful application of k-means to feature learning.\n\n\n=== Bilateral filtering ===\n\nk-means implicitly assumes that the ordering of the input data set does not matter. The bilateral filter is similar to k-means and mean shift in that it maintains a set of data points that are iteratively replaced by means. However, the bilateral filter restricts the calculation of the (kernel weighted) mean to include only points that are close in the ordering of the input data. This makes it applicable to problems such as image denoising, where the spatial arrangement of pixels in an image is of critical importance.\n\n\n== Similar problems ==\nThe set of squared error minimizing cluster functions also includes the k-medoids algorithm, an approach which forces the center point of each cluster to be one of the actual points, i.e., it uses medoids in place of centroids.\n\n\n== Software implementations ==\nDifferent implementations of the algorithm exhibit performance differences, with the fastest on a test data set finishing in 10 seconds, the slowest taking 25,988 seconds (~7 hours). The differences can be attributed to implementation quality, language and compiler differences, different termination criteria and precision levels, and the use of indexes for acceleration.\n\n\n=== Free Software/Open Source ===\nThe following implementations are available under Free/Open Source Software licenses, with publicly available source code.\n\nAccord.NET contains C# implementations for k-means, k-means++ and k-modes.\nALGLIB contains parallelized C++ and C# implementations for k-means and k-means++.\nAOSP contains a Java implementation for k-means.\nCrimeStat implements two spatial k-means algorithms, one of which allows the user to define the starting locations.\nELKI contains k-means (with Lloyd and MacQueen iteration, along with different initializations such as k-means++ initialization) and various more advanced clustering algorithms.\nSmile contains k-means and various more other algorithms and results visualization (for java, kotlin and scala).\nJulia contains a k-means implementation in the JuliaStats Clustering package.\nKNIME contains nodes for k-means and k-medoids.\nMahout contains a MapReduce based k-means.\nmlpack contains a C++ implementation of k-means.\nOctave contains k-means.\nOpenCV contains a k-means implementation.\nOrange includes a component for k-means clustering with automatic selection of k and cluster silhouette scoring.\nPSPP contains k-means, The QUICK CLUSTER command performs k-means clustering on the dataset.\nR contains three k-means variations.\nSciPy and scikit-learn contain multiple k-means implementations.\nSpark MLlib implements a distributed k-means algorithm.\nTorch contains an unsup package that provides k-means clustering.\nWeka contains k-means and x-means.\n\n\n=== Proprietary ===\nThe following implementations are available under proprietary license terms, and may not have publicly available source code.\n\n\n== See also ==\nK-medoids\nBFR algorithm\nCentroidal Voronoi tessellation\nCluster analysis\nDBSCAN\nHead/tail breaks\nk q-flats\nk-means++\nLinde–Buzo–Gray algorithm\nSelf-organizing map\n\n\n== References =="
}