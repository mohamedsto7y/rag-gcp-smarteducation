{
  "id": "doc_048",
  "title": "Autoencoder",
  "url": "https://en.wikipedia.org/wiki/Autoencoder",
  "topic": "Autoencoder",
  "content": "An autoencoder is a type of artificial neural network used to learn efficient codings of unlabeled data (unsupervised learning). An autoencoder learns two functions: an encoding function that transforms the input data, and a decoding function that recreates the input data from the encoded representation. The autoencoder learns an efficient representation (encoding) for a set of data, typically for dimensionality reduction, to generate lower-dimensional embeddings for subsequent use by other machine learning algorithms.\nVariants exist which aim to make the learned representations assume useful properties. Examples are regularized autoencoders (sparse, denoising and contractive autoencoders), which are effective in learning representations for subsequent classification tasks, and variational autoencoders, which can be used as generative models. Autoencoders are applied to many problems, including facial recognition, feature detection, anomaly detection, and learning the meaning of words. In terms of data synthesis, autoencoders can also be used to randomly generate new data that is similar to the input (training) data.\n\n\n== Mathematical principles ==\n\n\n=== Definition ===\nAn autoencoder is defined by the following components: Two sets: the space of encoded messages \n  \n    \n      \n        \n          \n            Z\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {Z}}}\n  \n; the space of decoded messages \n  \n    \n      \n        \n          \n            X\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {X}}}\n  \n. Typically \n  \n    \n      \n        \n          \n            X\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {X}}}\n  \n and \n  \n    \n      \n        \n          \n            Z\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {Z}}}\n  \n are Euclidean spaces, that is, \n  \n    \n      \n        \n          \n            X\n          \n        \n        =\n        \n          \n            R\n          \n          \n            m\n          \n        \n        ,\n        \n          \n            Z\n          \n        \n        =\n        \n          \n            R\n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {X}}=\\mathbb {R} ^{m},{\\mathcal {Z}}=\\mathbb {R} ^{n}}\n  \n with \n  \n    \n      \n        m\n        >\n        n\n        .\n      \n    \n    {\\displaystyle m>n.}\n  \n    Two parametrized families of functions: the encoder family \n  \n    \n      \n        \n          E\n          \n            ϕ\n          \n        \n        :\n        \n          \n            X\n          \n        \n        →\n        \n          \n            Z\n          \n        \n      \n    \n    {\\displaystyle E_{\\phi }:{\\mathcal {X}}\\rightarrow {\\mathcal {Z}}}\n  \n, parametrized by \n  \n    \n      \n        ϕ\n      \n    \n    {\\displaystyle \\phi }\n  \n; the decoder family \n  \n    \n      \n        \n          D\n          \n            θ\n          \n        \n        :\n        \n          \n            Z\n          \n        \n        →\n        \n          \n            X\n          \n        \n      \n    \n    {\\displaystyle D_{\\theta }:{\\mathcal {Z}}\\rightarrow {\\mathcal {X}}}\n  \n, parametrized by \n  \n    \n      \n        θ\n      \n    \n    {\\displaystyle \\theta }\n  \n.For any \n  \n    \n      \n        x\n        ∈\n        \n          \n            X\n          \n        \n      \n    \n    {\\displaystyle x\\in {\\mathcal {X}}}\n  \n, we usually write \n  \n    \n      \n        z\n        =\n        \n          E\n          \n            ϕ\n          \n        \n        (\n        x\n        )\n      \n    \n    {\\displaystyle z=E_{\\phi }(x)}\n  \n, and refer to it as the code, the latent variable, latent representation, latent vector, etc. Conversely, for any \n  \n    \n      \n        z\n        ∈\n        \n          \n            Z\n          \n        \n      \n    \n    {\\displaystyle z\\in {\\mathcal {Z}}}\n  \n, we usually write \n  \n    \n      \n        \n          x\n          ′\n        \n        =\n        \n          D\n          \n            θ\n          \n        \n        (\n        z\n        )\n      \n    \n    {\\displaystyle x'=D_{\\theta }(z)}\n  \n, and refer to it as the (decoded) message.\nUsually, both the encoder and the decoder are defined as multilayer perceptrons (MLPs). For example, a one-layer-MLP encoder \n  \n    \n      \n        \n          E\n          \n            ϕ\n          \n        \n      \n    \n    {\\displaystyle E_{\\phi }}\n  \n is:\n\n  \n    \n      \n        \n          E\n          \n            ϕ\n          \n        \n        (\n        \n          x\n        \n        )\n        =\n        σ\n        (\n        W\n        x\n        +\n        b\n        )\n      \n    \n    {\\displaystyle E_{\\phi }(\\mathbf {x} )=\\sigma (Wx+b)}\n  \n\nwhere \n  \n    \n      \n        σ\n      \n    \n    {\\displaystyle \\sigma }\n  \n is an element-wise activation function, \n  \n    \n      \n        W\n      \n    \n    {\\displaystyle W}\n  \n is a \"weight\" matrix, and \n  \n    \n      \n        b\n      \n    \n    {\\displaystyle b}\n  \n is a \"bias\" vector.\n\n\n=== Training an autoencoder ===\nAn autoencoder, by itself, is simply a tuple of two functions. To judge its quality, we need a task. A task is defined by a reference probability distribution \n  \n    \n      \n        \n          μ\n          \n            r\n            e\n            f\n          \n        \n      \n    \n    {\\displaystyle \\mu _{ref}}\n  \n over \n  \n    \n      \n        \n          \n            X\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {X}}}\n  \n, and a \"reconstruction quality\" function \n  \n    \n      \n        d\n        :\n        \n          \n            X\n          \n        \n        ×\n        \n          \n            X\n          \n        \n        →\n        [\n        0\n        ,\n        ∞\n        ]\n      \n    \n    {\\displaystyle d:{\\mathcal {X}}\\times {\\mathcal {X}}\\to [0,\\infty ]}\n  \n, such that \n  \n    \n      \n        d\n        (\n        x\n        ,\n        \n          x\n          ′\n        \n        )\n      \n    \n    {\\displaystyle d(x,x')}\n  \n measures how much \n  \n    \n      \n        \n          x\n          ′\n        \n      \n    \n    {\\displaystyle x'}\n  \n differs from \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n.\nWith those, we can define the loss function for the autoencoder as\n  \n    \n      \n        L\n        (\n        θ\n        ,\n        ϕ\n        )\n        :=\n        \n          \n            \n              E\n            \n          \n          \n            x\n            ∼\n            \n              μ\n              \n                r\n                e\n                f\n              \n            \n          \n        \n        [\n        d\n        (\n        x\n        ,\n        \n          D\n          \n            θ\n          \n        \n        (\n        \n          E\n          \n            ϕ\n          \n        \n        (\n        x\n        )\n        )\n        )\n        ]\n      \n    \n    {\\displaystyle L(\\theta ,\\phi ):=\\mathbb {\\mathbb {E} } _{x\\sim \\mu _{ref}}[d(x,D_{\\theta }(E_{\\phi }(x)))]}\n  \nThe optimal autoencoder for the given task \n  \n    \n      \n        (\n        \n          μ\n          \n            r\n            e\n            f\n          \n        \n        ,\n        d\n        )\n      \n    \n    {\\displaystyle (\\mu _{ref},d)}\n  \n is then \n  \n    \n      \n        arg\n        ⁡\n        \n          min\n          \n            θ\n            ,\n            ϕ\n          \n        \n        L\n        (\n        θ\n        ,\n        ϕ\n        )\n      \n    \n    {\\displaystyle \\arg \\min _{\\theta ,\\phi }L(\\theta ,\\phi )}\n  \n. The search for the optimal autoencoder can be accomplished by any mathematical optimization technique, but usually by gradient descent. This search process is referred to as \"training the autoencoder\".\nIn most situations, the reference distribution is just the empirical distribution given by a dataset \n  \n    \n      \n        {\n        \n          x\n          \n            1\n          \n        \n        ,\n        .\n        .\n        .\n        ,\n        \n          x\n          \n            N\n          \n        \n        }\n        ⊂\n        \n          \n            X\n          \n        \n      \n    \n    {\\displaystyle \\{x_{1},...,x_{N}\\}\\subset {\\mathcal {X}}}\n  \n, so that\n  \n    \n      \n        \n          μ\n          \n            r\n            e\n            f\n          \n        \n        =\n        \n          \n            1\n            N\n          \n        \n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            N\n          \n        \n        \n          δ\n          \n            \n              x\n              \n                i\n              \n            \n          \n        \n      \n    \n    {\\displaystyle \\mu _{ref}={\\frac {1}{N}}\\sum _{i=1}^{N}\\delta _{x_{i}}}\n  \n\nwhere \n  \n    \n      \n        \n          δ\n          \n            \n              x\n              \n                i\n              \n            \n          \n        \n      \n    \n    {\\displaystyle \\delta _{x_{i}}}\n  \n is the Dirac measure, the quality function is just L2 loss: \n  \n    \n      \n        d\n        (\n        x\n        ,\n        \n          x\n          ′\n        \n        )\n        =\n        ‖\n        x\n        −\n        \n          x\n          ′\n        \n        \n          ‖\n          \n            2\n          \n          \n            2\n          \n        \n      \n    \n    {\\displaystyle d(x,x')=\\|x-x'\\|_{2}^{2}}\n  \n, and \n  \n    \n      \n        ‖\n        ⋅\n        \n          ‖\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\|\\cdot \\|_{2}}\n  \n is the Euclidean norm. Then the problem of searching for the optimal autoencoder is just a least-squares optimization:\n  \n    \n      \n        \n          min\n          \n            θ\n            ,\n            ϕ\n          \n        \n        L\n        (\n        θ\n        ,\n        ϕ\n        )\n        ,\n        \n        \n          where \n        \n        L\n        (\n        θ\n        ,\n        ϕ\n        )\n        =\n        \n          \n            1\n            N\n          \n        \n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            N\n          \n        \n        ‖\n        \n          x\n          \n            i\n          \n        \n        −\n        \n          D\n          \n            θ\n          \n        \n        (\n        \n          E\n          \n            ϕ\n          \n        \n        (\n        \n          x\n          \n            i\n          \n        \n        )\n        )\n        \n          ‖\n          \n            2\n          \n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\min _{\\theta ,\\phi }L(\\theta ,\\phi ),\\qquad {\\text{where }}L(\\theta ,\\phi )={\\frac {1}{N}}\\sum _{i=1}^{N}\\|x_{i}-D_{\\theta }(E_{\\phi }(x_{i}))\\|_{2}^{2}}\n  \n\n\n=== Interpretation ===\nAn autoencoder has two main parts: an encoder that maps the message to a code, and a decoder that reconstructs the message from the code. An optimal autoencoder would perform as close to perfect reconstruction as possible, with \"close to perfect\" defined by the reconstruction quality function \n  \n    \n      \n        d\n      \n    \n    {\\displaystyle d}\n  \n.\nThe simplest way to perform the copying task perfectly would be to duplicate the signal. To suppress this behavior, the code space \n  \n    \n      \n        \n          \n            Z\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {Z}}}\n  \n usually has fewer dimensions than the message space \n  \n    \n      \n        \n          \n            X\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {X}}}\n  \n.\nSuch an autoencoder is called undercomplete. It can be interpreted as compressing the message, or reducing its dimensionality.\nAt the limit of an ideal undercomplete autoencoder, every possible code \n  \n    \n      \n        z\n      \n    \n    {\\displaystyle z}\n  \n in the code space is used to encode a message \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n that really appears in the distribution \n  \n    \n      \n        \n          μ\n          \n            r\n            e\n            f\n          \n        \n      \n    \n    {\\displaystyle \\mu _{ref}}\n  \n, and the decoder is also perfect: \n  \n    \n      \n        \n          D\n          \n            θ\n          \n        \n        (\n        \n          E\n          \n            ϕ\n          \n        \n        (\n        x\n        )\n        )\n        =\n        x\n      \n    \n    {\\displaystyle D_{\\theta }(E_{\\phi }(x))=x}\n  \n. This ideal autoencoder can then be used to generate messages indistinguishable from real messages, by feeding its decoder arbitrary code \n  \n    \n      \n        z\n      \n    \n    {\\displaystyle z}\n  \n and obtaining \n  \n    \n      \n        \n          D\n          \n            θ\n          \n        \n        (\n        z\n        )\n      \n    \n    {\\displaystyle D_{\\theta }(z)}\n  \n, which is a message that really appears in the distribution \n  \n    \n      \n        \n          μ\n          \n            r\n            e\n            f\n          \n        \n      \n    \n    {\\displaystyle \\mu _{ref}}\n  \n.\nIf the code space \n  \n    \n      \n        \n          \n            Z\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {Z}}}\n  \n has dimension larger than (overcomplete), or equal to, the message space \n  \n    \n      \n        \n          \n            X\n          \n        \n      \n    \n    {\\displaystyle {\\mathcal {X}}}\n  \n, or the hidden units are given enough capacity, an autoencoder can learn the identity function and become useless. However, experimental results found that overcomplete autoencoders might still learn useful features.\nIn the ideal setting, the code dimension and the model capacity could be set on the basis of the complexity of the data distribution to be modeled. A standard way to do so is to add modifications to the basic autoencoder, to be detailed below.\n\n\n== Variations ==\n\n\n=== Variational autoencoder (VAE) ===\n\nVariational autoencoders (VAEs) belong to the families of variational Bayesian methods. Despite the architectural similarities with basic autoencoders, VAEs are architected with different goals and have a different mathematical formulation. The latent space is, in this case, composed of a mixture of distributions instead of fixed vectors.\nGiven an input dataset \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n characterized by an unknown probability function \n  \n    \n      \n        P\n        (\n        x\n        )\n      \n    \n    {\\displaystyle P(x)}\n  \n and a multivariate latent encoding vector \n  \n    \n      \n        z\n      \n    \n    {\\displaystyle z}\n  \n, the objective is to model the data as a distribution \n  \n    \n      \n        \n          p\n          \n            θ\n          \n        \n        (\n        x\n        )\n      \n    \n    {\\displaystyle p_{\\theta }(x)}\n  \n, with \n  \n    \n      \n        θ\n      \n    \n    {\\displaystyle \\theta }\n  \n defined as the set of the network parameters so that \n  \n    \n      \n        \n          p\n          \n            θ\n          \n        \n        (\n        x\n        )\n        =\n        \n          ∫\n          \n            z\n          \n        \n        \n          p\n          \n            θ\n          \n        \n        (\n        x\n        ,\n        z\n        )\n        d\n        z\n      \n    \n    {\\displaystyle p_{\\theta }(x)=\\int _{z}p_{\\theta }(x,z)dz}\n  \n.\n\n\n=== Sparse autoencoder (SAE) ===\nInspired by the sparse coding hypothesis in neuroscience, sparse autoencoders (SAE) are variants of autoencoders, such that the codes \n  \n    \n      \n        \n          E\n          \n            ϕ\n          \n        \n        (\n        x\n        )\n      \n    \n    {\\displaystyle E_{\\phi }(x)}\n  \n for messages tend to be sparse codes, that is, \n  \n    \n      \n        \n          E\n          \n            ϕ\n          \n        \n        (\n        x\n        )\n      \n    \n    {\\displaystyle E_{\\phi }(x)}\n  \n is close to zero in most entries. Sparse autoencoders may include more (rather than fewer) hidden units than inputs, but only a small number of the hidden units are allowed to be active at the same time. Encouraging sparsity improves performance on classification tasks. \nThere are two main ways to enforce sparsity. One way is to simply clamp all but the highest-k activations of the latent code to zero. This is the k-sparse autoencoder.\nThe k-sparse autoencoder inserts the following \"k-sparse function\" in the latent layer of a standard autoencoder:\n  \n    \n      \n        \n          f\n          \n            k\n          \n        \n        (\n        \n          x\n          \n            1\n          \n        \n        ,\n        .\n        .\n        .\n        ,\n        \n          x\n          \n            n\n          \n        \n        )\n        =\n        (\n        \n          x\n          \n            1\n          \n        \n        \n          b\n          \n            1\n          \n        \n        ,\n        .\n        .\n        .\n        ,\n        \n          x\n          \n            n\n          \n        \n        \n          b\n          \n            n\n          \n        \n        )\n      \n    \n    {\\displaystyle f_{k}(x_{1},...,x_{n})=(x_{1}b_{1},...,x_{n}b_{n})}\n  \nwhere \n  \n    \n      \n        \n          b\n          \n            i\n          \n        \n        =\n        1\n      \n    \n    {\\displaystyle b_{i}=1}\n  \n if \n  \n    \n      \n        \n          |\n        \n        \n          x\n          \n            i\n          \n        \n        \n          |\n        \n      \n    \n    {\\displaystyle |x_{i}|}\n  \n ranks in the top k, and 0 otherwise.\nBackpropagating through \n  \n    \n      \n        \n          f\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle f_{k}}\n  \n is simple: set gradient to 0 for \n  \n    \n      \n        \n          b\n          \n            i\n          \n        \n        =\n        0\n      \n    \n    {\\displaystyle b_{i}=0}\n  \n entries, and keep gradient for \n  \n    \n      \n        \n          b\n          \n            i\n          \n        \n        =\n        1\n      \n    \n    {\\displaystyle b_{i}=1}\n  \n entries. This is essentially a generalized ReLU function.\nThe other way is a relaxed version of the k-sparse autoencoder. Instead of forcing sparsity, we add a sparsity regularization loss, then optimize for\n  \n    \n      \n        \n          min\n          \n            θ\n            ,\n            ϕ\n          \n        \n        L\n        (\n        θ\n        ,\n        ϕ\n        )\n        +\n        λ\n        \n          L\n          \n            sparse\n          \n        \n        (\n        θ\n        ,\n        ϕ\n        )\n      \n    \n    {\\displaystyle \\min _{\\theta ,\\phi }L(\\theta ,\\phi )+\\lambda L_{\\text{sparse}}(\\theta ,\\phi )}\n  \nwhere \n  \n    \n      \n        λ\n        >\n        0\n      \n    \n    {\\displaystyle \\lambda >0}\n  \n measures how much sparsity we want to enforce.\nLet the autoencoder architecture have \n  \n    \n      \n        K\n      \n    \n    {\\displaystyle K}\n  \n layers. To define a sparsity regularization loss, we need a \"desired\" sparsity \n  \n    \n      \n        \n          \n            \n              \n                ρ\n                ^\n              \n            \n          \n          \n            k\n          \n        \n      \n    \n    {\\displaystyle {\\hat {\\rho }}_{k}}\n  \n for each layer, a weight \n  \n    \n      \n        \n          w\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle w_{k}}\n  \n for how much to enforce each sparsity, and a function \n  \n    \n      \n        s\n        :\n        [\n        0\n        ,\n        1\n        ]\n        ×\n        [\n        0\n        ,\n        1\n        ]\n        →\n        [\n        0\n        ,\n        ∞\n        ]\n      \n    \n    {\\displaystyle s:[0,1]\\times [0,1]\\to [0,\\infty ]}\n  \n to measure how much two sparsities differ.\nFor each input \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n, let the actual sparsity of activation in each layer \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n be\n  \n    \n      \n        \n          ρ\n          \n            k\n          \n        \n        (\n        x\n        )\n        =\n        \n          \n            1\n            n\n          \n        \n        \n          ∑\n          \n            i\n            =\n            1\n          \n          \n            n\n          \n        \n        \n          a\n          \n            k\n            ,\n            i\n          \n        \n        (\n        x\n        )\n      \n    \n    {\\displaystyle \\rho _{k}(x)={\\frac {1}{n}}\\sum _{i=1}^{n}a_{k,i}(x)}\n  \nwhere \n  \n    \n      \n        \n          a\n          \n            k\n            ,\n            i\n          \n        \n        (\n        x\n        )\n      \n    \n    {\\displaystyle a_{k,i}(x)}\n  \n is the activation in the \n  \n    \n      \n        i\n      \n    \n    {\\displaystyle i}\n  \n -th neuron of the \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n -th layer upon input \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n.\nThe sparsity loss upon input \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n for one layer is \n  \n    \n      \n        s\n        (\n        \n          \n            \n              \n                ρ\n                ^\n              \n            \n          \n          \n            k\n          \n        \n        ,\n        \n          ρ\n          \n            k\n          \n        \n        (\n        x\n        )\n        )\n      \n    \n    {\\displaystyle s({\\hat {\\rho }}_{k},\\rho _{k}(x))}\n  \n, and the sparsity regularization loss for the entire autoencoder is the expected weighted sum of sparsity losses:\n  \n    \n      \n        \n          L\n          \n            sparse\n          \n        \n        (\n        θ\n        ,\n        ϕ\n        )\n        =\n        \n          \n            \n              E\n            \n          \n          \n            x\n            ∼\n            \n              μ\n              \n                X\n              \n            \n          \n        \n        \n          [\n          \n            \n              ∑\n              \n                k\n                ∈\n                1\n                :\n                K\n              \n            \n            \n              w\n              \n                k\n              \n            \n            s\n            (\n            \n              \n                \n                  \n                    ρ\n                    ^\n                  \n                \n              \n              \n                k\n              \n            \n            ,\n            \n              ρ\n              \n                k\n              \n            \n            (\n            x\n            )\n            )\n          \n          ]\n        \n      \n    \n    {\\displaystyle L_{\\text{sparse}}(\\theta ,\\phi )=\\mathbb {\\mathbb {E} } _{x\\sim \\mu _{X}}\\left[\\sum _{k\\in 1:K}w_{k}s({\\hat {\\rho }}_{k},\\rho _{k}(x))\\right]}\n  \nTypically, the function \n  \n    \n      \n        s\n      \n    \n    {\\displaystyle s}\n  \n is either the Kullback–Leibler (KL) divergence, as\n\n  \n    \n      \n        s\n        (\n        ρ\n        ,\n        \n          \n            \n              ρ\n              ^\n            \n          \n        \n        )\n        =\n        K\n        L\n        (\n        ρ\n        \n          |\n        \n        \n          |\n        \n        \n          \n            \n              ρ\n              ^\n            \n          \n        \n        )\n        =\n        ρ\n        log\n        ⁡\n        \n          \n            ρ\n            \n              \n                ρ\n                ^\n              \n            \n          \n        \n        +\n        (\n        1\n        −\n        ρ\n        )\n        log\n        ⁡\n        \n          \n            \n              1\n              −\n              ρ\n            \n            \n              1\n              −\n              \n                \n                  \n                    ρ\n                    ^\n                  \n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle s(\\rho ,{\\hat {\\rho }})=KL(\\rho ||{\\hat {\\rho }})=\\rho \\log {\\frac {\\rho }{\\hat {\\rho }}}+(1-\\rho )\\log {\\frac {1-\\rho }{1-{\\hat {\\rho }}}}}\n  \n\nor the L1 loss, as \n  \n    \n      \n        s\n        (\n        ρ\n        ,\n        \n          \n            \n              ρ\n              ^\n            \n          \n        \n        )\n        =\n        \n          |\n        \n        ρ\n        −\n        \n          \n            \n              ρ\n              ^\n            \n          \n        \n        \n          |\n        \n      \n    \n    {\\displaystyle s(\\rho ,{\\hat {\\rho }})=|\\rho -{\\hat {\\rho }}|}\n  \n, or the L2 loss, as \n  \n    \n      \n        s\n        (\n        ρ\n        ,\n        \n          \n            \n              ρ\n              ^\n            \n          \n        \n        )\n        =\n        \n          |\n        \n        ρ\n        −\n        \n          \n            \n              ρ\n              ^\n            \n          \n        \n        \n          \n            |\n          \n          \n            2\n          \n        \n      \n    \n    {\\displaystyle s(\\rho ,{\\hat {\\rho }})=|\\rho -{\\hat {\\rho }}|^{2}}\n  \n.\nAlternatively, the sparsity regularization loss may be defined without reference to any \"desired sparsity\", but simply force as much sparsity as possible. In this case, one can define the sparsity regularization loss as \n  \n    \n      \n        \n          L\n          \n            sparse\n          \n        \n        (\n        θ\n        ,\n        ϕ\n        )\n        =\n        \n          \n            \n              E\n            \n          \n          \n            x\n            ∼\n            \n              μ\n              \n                X\n              \n            \n          \n        \n        \n          [\n          \n            \n              ∑\n              \n                k\n                ∈\n                1\n                :\n                K\n              \n            \n            \n              w\n              \n                k\n              \n            \n            ‖\n            \n              h\n              \n                k\n              \n            \n            ‖\n          \n          ]\n        \n      \n    \n    {\\displaystyle L_{\\text{sparse}}(\\theta ,\\phi )=\\mathbb {\\mathbb {E} } _{x\\sim \\mu _{X}}\\left[\\sum _{k\\in 1:K}w_{k}\\|h_{k}\\|\\right]}\n  \nwhere \n  \n    \n      \n        \n          h\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle h_{k}}\n  \n is the activation vector in the \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n-th layer of the autoencoder. The norm \n  \n    \n      \n        ‖\n        ⋅\n        ‖\n      \n    \n    {\\displaystyle \\|\\cdot \\|}\n  \n is usually the L1 norm (giving the L1 sparse autoencoder) or the L2 norm (giving the L2 sparse autoencoder).\n\n\n=== Denoising autoencoder (DAE) ===\n\nDenoising autoencoders (DAE) try to achieve a good representation by changing the reconstruction criterion.\nA DAE, originally called a \"robust autoassociative network\" by Mark A. Kramer, is trained by intentionally corrupting the inputs of a standard autoencoder during training. A noise process is defined by a probability distribution \n  \n    \n      \n        \n          μ\n          \n            T\n          \n        \n      \n    \n    {\\displaystyle \\mu _{T}}\n  \n over functions \n  \n    \n      \n        T\n        :\n        \n          \n            X\n          \n        \n        →\n        \n          \n            X\n          \n        \n      \n    \n    {\\displaystyle T:{\\mathcal {X}}\\to {\\mathcal {X}}}\n  \n. That is, the function \n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n takes a message \n  \n    \n      \n        x\n        ∈\n        \n          \n            X\n          \n        \n      \n    \n    {\\displaystyle x\\in {\\mathcal {X}}}\n  \n, and corrupts it to a noisy version \n  \n    \n      \n        T\n        (\n        x\n        )\n      \n    \n    {\\displaystyle T(x)}\n  \n. The function \n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n is selected randomly, with a probability distribution \n  \n    \n      \n        \n          μ\n          \n            T\n          \n        \n      \n    \n    {\\displaystyle \\mu _{T}}\n  \n.\nGiven a task \n  \n    \n      \n        (\n        \n          μ\n          \n            ref\n          \n        \n        ,\n        d\n        )\n      \n    \n    {\\displaystyle (\\mu _{\\text{ref}},d)}\n  \n, the problem of training a DAE is the optimization problem:\n  \n    \n      \n        \n          min\n          \n            θ\n            ,\n            ϕ\n          \n        \n        L\n        (\n        θ\n        ,\n        ϕ\n        )\n        =\n        \n          \n            \n              E\n            \n          \n          \n            x\n            ∼\n            \n              μ\n              \n                X\n              \n            \n            ,\n            T\n            ∼\n            \n              μ\n              \n                T\n              \n            \n          \n        \n        [\n        d\n        (\n        x\n        ,\n        (\n        \n          D\n          \n            θ\n          \n        \n        ∘\n        \n          E\n          \n            ϕ\n          \n        \n        ∘\n        T\n        )\n        (\n        x\n        )\n        )\n        ]\n      \n    \n    {\\displaystyle \\min _{\\theta ,\\phi }L(\\theta ,\\phi )=\\mathbb {\\mathbb {E} } _{x\\sim \\mu _{X},T\\sim \\mu _{T}}[d(x,(D_{\\theta }\\circ E_{\\phi }\\circ T)(x))]}\n  \nThat is, the optimal DAE should take any noisy message and attempt to recover the original message without noise, thus the name \"denoising\".\nUsually, the noise process \n  \n    \n      \n        T\n      \n    \n    {\\displaystyle T}\n  \n is applied only during training and testing, not during downstream use.\nThe use of DAE depends on two assumptions:\n\nThere exist representations to the messages that are relatively stable and robust to the type of noise we are likely to encounter;\nThe said representations capture structures in the input distribution that are useful for our purposes.\nExample noise processes include:\n\nadditive isotropic Gaussian noise,\nmasking noise (a fraction of the input is randomly chosen and set to 0)\nsalt-and-pepper noise (a fraction of the input is randomly chosen and randomly set to its minimum or maximum value).\n\n\n=== Contractive autoencoder (CAE) ===\nA contractive autoencoder (CAE) adds the contractive regularization loss to the standard autoencoder loss:\n  \n    \n      \n        \n          min\n          \n            θ\n            ,\n            ϕ\n          \n        \n        L\n        (\n        θ\n        ,\n        ϕ\n        )\n        +\n        λ\n        \n          L\n          \n            cont\n          \n        \n        (\n        θ\n        ,\n        ϕ\n        )\n      \n    \n    {\\displaystyle \\min _{\\theta ,\\phi }L(\\theta ,\\phi )+\\lambda L_{\\text{cont}}(\\theta ,\\phi )}\n  \nwhere \n  \n    \n      \n        λ\n        >\n        0\n      \n    \n    {\\displaystyle \\lambda >0}\n  \n measures how much contractive-ness we want to enforce. The contractive regularization loss itself is defined as the expected square of Frobenius norm of the Jacobian matrix of the encoder activations with respect to the input:\n  \n    \n      \n        \n          L\n          \n            cont\n          \n        \n        (\n        θ\n        ,\n        ϕ\n        )\n        =\n        \n          \n            E\n          \n          \n            x\n            ∼\n            \n              μ\n              \n                r\n                e\n                f\n              \n            \n          \n        \n        ‖\n        \n          ∇\n          \n            x\n          \n        \n        \n          E\n          \n            ϕ\n          \n        \n        (\n        x\n        )\n        \n          ‖\n          \n            F\n          \n          \n            2\n          \n        \n      \n    \n    {\\displaystyle L_{\\text{cont}}(\\theta ,\\phi )=\\mathbb {E} _{x\\sim \\mu _{ref}}\\|\\nabla _{x}E_{\\phi }(x)\\|_{F}^{2}}\n  \nTo understand what \n  \n    \n      \n        \n          L\n          \n            cont\n          \n        \n      \n    \n    {\\displaystyle L_{\\text{cont}}}\n  \n measures, note the fact\n  \n    \n      \n        ‖\n        \n          E\n          \n            ϕ\n          \n        \n        (\n        x\n        +\n        δ\n        x\n        )\n        −\n        \n          E\n          \n            ϕ\n          \n        \n        (\n        x\n        )\n        \n          ‖\n          \n            2\n          \n        \n        ≤\n        ‖\n        \n          ∇\n          \n            x\n          \n        \n        \n          E\n          \n            ϕ\n          \n        \n        (\n        x\n        )\n        \n          ‖\n          \n            F\n          \n        \n        ‖\n        δ\n        x\n        \n          ‖\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\|E_{\\phi }(x+\\delta x)-E_{\\phi }(x)\\|_{2}\\leq \\|\\nabla _{x}E_{\\phi }(x)\\|_{F}\\|\\delta x\\|_{2}}\n  \nfor any message \n  \n    \n      \n        x\n        ∈\n        \n          \n            X\n          \n        \n      \n    \n    {\\displaystyle x\\in {\\mathcal {X}}}\n  \n, and small variation \n  \n    \n      \n        δ\n        x\n      \n    \n    {\\displaystyle \\delta x}\n  \n in it. Thus, if \n  \n    \n      \n        ‖\n        \n          ∇\n          \n            x\n          \n        \n        \n          E\n          \n            ϕ\n          \n        \n        (\n        x\n        )\n        \n          ‖\n          \n            F\n          \n          \n            2\n          \n        \n      \n    \n    {\\displaystyle \\|\\nabla _{x}E_{\\phi }(x)\\|_{F}^{2}}\n  \n is small, it means that a small neighborhood of the message maps to a small neighborhood of its code. This is a desired property, as it means small variation in the message leads to small, perhaps even zero, variation in its code, like how two pictures may look the same even if they are not exactly the same.\nThe DAE can be understood as an infinitesimal limit of CAE: in the limit of small Gaussian input noise, DAEs make the reconstruction function resist small but finite-sized input perturbations, while CAEs make the extracted features resist infinitesimal input perturbations.\n\n\n=== Minimum description length autoencoder (MDL-AE) ===\nA minimum description length autoencoder (MDL-AE) is an advanced variation of the traditional autoencoder, which leverages principles from information theory, specifically the Minimum Description Length (MDL) principle. The MDL principle posits that the best model for a dataset is the one that provides the shortest combined encoding of the model and the data. In the context of autoencoders, this principle is applied to ensure that the learned representation is not only compact but also interpretable and efficient for reconstruction.\nThe MDL-AE seeks to minimize the total description length of the data, which includes the size of the latent representation (code length) and the error in reconstructing the original data. The objective can be expressed as\n\n  \n    \n      \n        \n          L\n          \n            code\n          \n        \n        +\n        \n          L\n          \n            error\n          \n        \n      \n    \n    {\\displaystyle L_{\\text{code}}+L_{\\text{error}}}\n  \n, where \n  \n    \n      \n        \n          L\n          \n            code\n          \n        \n      \n    \n    {\\displaystyle L_{\\text{code}}}\n  \n represents the length of the compressed latent representation and \n  \n    \n      \n        \n          L\n          \n            error\n          \n        \n      \n    \n    {\\displaystyle L_{\\text{error}}}\n  \n denotes the reconstruction error.\n\n\n=== Concrete autoencoder (CAE) ===\nThe concrete autoencoder is designed for discrete feature selection. A concrete autoencoder forces the latent space to consist only of a user-specified number of features. The concrete autoencoder uses a continuous relaxation of the categorical distribution to allow gradients to pass through the feature selector layer, which makes it possible to use standard backpropagation to learn an optimal subset of input features that minimize reconstruction loss.\n\n\n== Advantages of depth ==\n\nAutoencoders are often trained with a single-layer encoder and a single-layer decoder, but using many-layered (deep) encoders and decoders offers many advantages.\n\nDepth can exponentially reduce the computational cost of representing some functions.\nDepth can exponentially decrease the amount of training data needed to learn some functions.\nExperimentally, deep autoencoders yield better compression compared to shallow or linear autoencoders.\nDepth allows for advantages over traditional methods as one can show that after training single layer linear autoencoders have a latent space whose vectors span the same subspace as the eigenvectors found in Principal component analysis.\n\n\n=== Training ===\nGeoffrey Hinton developed the deep belief network technique for training many-layered deep autoencoders. His method involves treating each neighboring set of two layers as a restricted Boltzmann machine so that pretraining approximates a good solution, then using backpropagation to fine-tune the results.\nResearchers have debated whether joint training (i.e. training the whole architecture together with a single global reconstruction objective to optimize) would be better for deep auto-encoders. A 2015 study showed that joint training learns better data models along with more representative features for classification as compared to the layerwise method. However, their experiments showed that the success of joint training depends heavily on the regularization strategies adopted.\n\n\n== History ==\n(Oja, 1982) noted that PCA is equivalent to a neural network with one hidden layer with identity activation function. In the language of autoencoding, the input-to-hidden module is the encoder, and the hidden-to-output module is the decoder. Subsequently, in (Baldi and Hornik, 1989) and (Kramer, 1991) generalized PCA to autoencoders, a technique which they termed \"nonlinear PCA\".\nImmediately after the resurgence of neural networks in the 1980s, it was suggested in 1986 that a neural network be put in \"auto-association mode\". This was then implemented in (Harrison, 1987) and (Elman, Zipser, 1988) for speech and in (Cottrell, Munro, Zipser, 1987) for images. In (Hinton, Salakhutdinov, 2006), deep belief networks were developed. These train a pair restricted Boltzmann machines as encoder-decoder pairs, then train another pair on the latent representation of the first pair, and so on.\nThe first applications of AE date to early 1990s. Their most traditional application was dimensionality reduction or feature learning, but the concept became widely used for learning generative models of data. Some of the most powerful AIs in the 2010s involved autoencoder modules as a component of larger AI systems, such as VAE in Stable Diffusion, discrete VAE in Transformer-based image generators like DALL-E 1, etc.\nDuring the early days, when the terminology was uncertain, the autoencoder has also been called identity mapping, auto-associating, self-supervised backpropagation, or Diabolo network.\n\n\n== Applications ==\nThe two main applications of autoencoders are dimensionality reduction and information retrieval (or associative memory), but modern variations have been applied to other tasks.\n\n\n=== Dimensionality reduction ===\nDimensionality reduction was one of the first deep learning applications.\nFor Hinton's 2006 study, he pretrained a multi-layer autoencoder with a stack of RBMs and then used their weights to initialize a deep autoencoder with gradually smaller hidden layers until hitting a bottleneck of 30 neurons. The resulting 30 dimensions of the code yielded a smaller reconstruction error compared to the first 30 components of a principal component analysis (PCA), and learned a representation that was qualitatively easier to interpret, clearly separating data clusters.\nReducing dimensions can improve performance on tasks such as classification. Indeed, the hallmark of dimensionality reduction is to place semantically related examples near each other.\n\n\n==== Principal component analysis ====\n\nIf linear activations are used, or only a single sigmoid hidden layer, then the optimal solution to an autoencoder is strongly related to principal component analysis (PCA). The weights of an autoencoder with a single hidden layer of size \n  \n    \n      \n        p\n      \n    \n    {\\displaystyle p}\n  \n (where \n  \n    \n      \n        p\n      \n    \n    {\\displaystyle p}\n  \n is less than the size of the input) span the same vector subspace as the one spanned by the first \n  \n    \n      \n        p\n      \n    \n    {\\displaystyle p}\n  \n principal components, and the output of the autoencoder is an orthogonal projection onto this subspace. The autoencoder weights are not equal to the principal components, and are generally not orthogonal, yet the principal components may be recovered from them using the singular value decomposition.\nHowever, the potential of autoencoders resides in their non-linearity, allowing the model to learn more powerful generalizations compared to PCA, and to reconstruct the input with significantly lower information loss.\n\n\n=== Information retrieval ===\nInformation retrieval benefits particularly from dimensionality reduction in that search can become more efficient in certain kinds of low dimensional spaces. Autoencoders were indeed applied to semantic hashing, proposed by Salakhutdinov and Hinton in 2007. By training the algorithm to produce a low-dimensional binary code, all database entries could be stored in a hash table mapping binary code vectors to entries. This table would then support information retrieval by returning all entries with the same binary code as the query, or slightly less similar entries by flipping some bits from the query encoding.\n\n\n=== Autoencoder hippocampus network ===\nAn autoencoder hippocampus network is a neural network that combines the principles of an autoencoder with a model of the hippocampus's memory functions to perform tasks like skill acquisition and recall in artificial systems. An autoencoder compresses policy function parameters into a compressed \"skill vector\" and then reconstructs the original data, mirroring the hippocampus's ability to encode and recall information. This framework can be used to learn, store, and retrieve different skills or memories, such as policy function parameters for a robot, by creating a latent space representation of these skills.\n\n\n=== Anomaly detection ===\nAnother application for autoencoders is anomaly detection. By learning to replicate the most salient features in the training data under some of the constraints described previously, the model is encouraged to learn to precisely reproduce the most frequently observed characteristics. When facing anomalies, the model should worsen its reconstruction performance. In most cases, only data with normal instances are used to train the autoencoder; in others, the frequency of anomalies is small compared to the observation set so that its contribution to the learned representation could be ignored. After training, the autoencoder will accurately reconstruct \"normal\" data, while failing to do so with unfamiliar anomalous data. Reconstruction error (the error between the original data and its low dimensional reconstruction) is used as an anomaly score to detect anomalies.\nTypically, this means that on a validation set the empirical distribution of reconstruction errors is recorded and then (e.g.) the empirical 95-percentile \n  \n    \n      \n        \n          x\n          \n            p\n          \n        \n      \n    \n    {\\displaystyle x_{p}}\n  \n is taken as threshold \n  \n    \n      \n        t\n        :=\n        \n          x\n          \n            p\n          \n        \n      \n    \n    {\\displaystyle t:=x_{p}}\n  \n to flag anomalous data points: \n  \n    \n      \n        \n          loss\n        \n        (\n        x\n        ,\n        \n          reconstruction\n        \n        (\n        x\n        )\n        )\n        >\n        t\n        \n        ⟹\n        \n        \n          anomaly\n        \n      \n    \n    {\\displaystyle {\\text{loss}}(x,{\\text{reconstruction}}(x))>t\\implies {\\text{anomaly}}}\n  \n. Since the threshold is an empirical quantile estimate, there is an inherent difficulty with \"correctly\" setting this threshold:\nIn many cases the distribution of the empirical quantile is asymptotically a normal distribution \n  \n    \n      \n        \n          empirical p-quantile\n        \n        ∼\n        \n          \n            N\n          \n        \n        \n          (\n          \n            μ\n            =\n            p\n            ,\n            \n              σ\n              \n                2\n              \n            \n            =\n            \n              \n                \n                  p\n                  (\n                  1\n                  −\n                  p\n                  )\n                \n                \n                  n\n                  f\n                  (\n                  \n                    x\n                    \n                      p\n                    \n                  \n                  \n                    )\n                    \n                      2\n                    \n                  \n                \n              \n            \n          \n          )\n        \n        ,\n      \n    \n    {\\displaystyle {\\text{empirical p-quantile}}\\sim {\\mathcal {N}}\\left(\\mu =p,\\sigma ^{2}={\\frac {p(1-p)}{nf(x_{p})^{2}}}\\right),}\n  \n with \n  \n    \n      \n        f\n        (\n        \n          x\n          \n            p\n          \n        \n        )\n      \n    \n    {\\displaystyle f(x_{p})}\n  \n the probability density at the quantile. This means that the variance grows if an extreme quantile is considered (because \n  \n    \n      \n        f\n        (\n        \n          x\n          \n            p\n          \n        \n        )\n      \n    \n    {\\displaystyle f(x_{p})}\n  \n is small there). This means that there is a, potentially, a big uncertainty in what is the right choice for the threshold since it is estimated from a validation set.\nRecent literature has however shown that certain autoencoding models can, counterintuitively, be very good at reconstructing anomalous examples and consequently not able to reliably perform anomaly detection. \nIntuitively, this can be understood by considering those one layer auto encoders which are related to PCA - also in this case there can be perfect rein reconstructions for points which are far away from the data region but which lie on a principal component axis.\nIt is best to analyze if the anomalies which are flagged by the auto encoder are true anomalies. In this sense all the metrics in Evaluation of binary classifiers can be considered. The fundamental challenge which comes with the unsupervised (self-supervised) learning setting is, that labels for rare events do not exist (in which case the labels first have to be gathered and the data set will be imbalanced) or anomaly indicating labels are very rare, introducing larger confidence intervals for these performance estimates.\n\n\n=== Image processing ===\nThe characteristics of autoencoders are useful in image processing.\nOne example can be found in lossy image compression, where autoencoders outperformed other approaches and proved competitive against JPEG 2000.\nAnother useful application of autoencoders in image preprocessing is image denoising.\nAutoencoders found use in more demanding contexts such as medical imaging where they have been used for image denoising as well as super-resolution. In image-assisted diagnosis, experiments have applied autoencoders for breast cancer detection and for modelling the relation between the cognitive decline of Alzheimer's disease and the latent features of an autoencoder trained with MRI.\n\n\n=== Drug discovery ===\nIn 2019 molecules generated with variational autoencoders were validated experimentally in mice.\n\n\n=== Popularity prediction ===\nRecently, a stacked autoencoder framework produced promising results in predicting popularity of social media posts, which is helpful for online advertising strategies.\n\n\n=== Machine translation ===\nAutoencoders have been applied to machine translation, which is usually referred to as neural machine translation (NMT). Unlike traditional autoencoders, the output does not match the input - it is in another language. In NMT, texts are treated as sequences to be encoded into the learning procedure, while on the decoder side sequences in the target language(s) are generated. Language-specific autoencoders incorporate further linguistic features into the learning procedure, such as Chinese decomposition features. Machine translation is rarely still done with autoencoders, due to the availability of more effective transformer networks.\n\n\n=== Communication Systems ===\nAutoencoders in communication systems are important because they help in encoding data into a more resilient representation for channel impairments, which is crucial for transmitting information while minimizing errors. In Addition, AE-based systems can optimize end-to-end communication performance. This approach can solve the several limitations of designing communication systems such as the inherent difficulty in accurately modeling the complex behavior of real-world channels.\n\n\n== See also ==\nRepresentation learning\nSingular value decomposition\nSparse dictionary learning\nDeep learning\n\n\n== Further reading ==\nBank, Dor; Koenigstein, Noam; Giryes, Raja (2023). \"Autoencoders\". Machine Learning for Data Science Handbook. Cham: Springer International Publishing. doi:10.1007/978-3-031-24628-9_16. ISBN 978-3-031-24627-2.\nGoodfellow, Ian; Bengio, Yoshua; Courville, Aaron (2016). \"14. Autoencoders\". Deep learning. Adaptive computation and machine learning. Cambridge, Mass: The MIT press. ISBN 978-0-262-03561-3.\n\n\n== References =="
}