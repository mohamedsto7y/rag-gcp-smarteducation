{
  "id": "doc_009",
  "title": "Backpropagation",
  "url": "https://en.wikipedia.org/wiki/Backpropagation",
  "topic": "Backpropagation",
  "content": "In machine learning, backpropagation is a gradient computation method commonly used for training a neural network in computing parameter updates.\nIt is an efficient application of the chain rule to neural networks. Backpropagation computes the gradient of a loss function with respect to the weights of the network for a single input–output example, and does so efficiently, computing the gradient one layer at a time, iterating backward from the last layer to avoid redundant calculations of intermediate terms in the chain rule; this can be derived through dynamic programming.\nStrictly speaking, the term backpropagation refers only to an algorithm for efficiently computing the gradient, not how the gradient is used; but the term is often used loosely to refer to the entire learning algorithm. This includes changing model parameters in the negative direction of the gradient, such as by stochastic gradient descent, or as an intermediate step in a more complicated optimizer, such as Adaptive Moment Estimation.\nBackpropagation had multiple discoveries and partial discoveries, with a tangled history and terminology. See the history section for details. Some other names for the technique include \"reverse mode of automatic differentiation\" or \"reverse accumulation\".\n\n\n== Overview ==\nBackpropagation computes the gradient in weight space of a feedforward neural network, with respect to a loss function. Denote:\n\n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n: input (vector of features)\n\n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n: target output\nFor classification, output will be a vector of class probabilities (e.g., \n  \n    \n      \n        (\n        0.1\n        ,\n        0.7\n        ,\n        0.2\n        )\n      \n    \n    {\\displaystyle (0.1,0.7,0.2)}\n  \n, and target output is a specific class, encoded by the one-hot/dummy variable (e.g., \n  \n    \n      \n        (\n        0\n        ,\n        1\n        ,\n        0\n        )\n      \n    \n    {\\displaystyle (0,1,0)}\n  \n).\n\n  \n    \n      \n        C\n      \n    \n    {\\displaystyle C}\n  \n: loss function or \"cost function\"\nFor classification, this is usually cross-entropy (XC, log loss), while for regression it is usually squared error loss (SEL).\n\n  \n    \n      \n        L\n      \n    \n    {\\displaystyle L}\n  \n: the number of layers\n\n  \n    \n      \n        \n          W\n          \n            l\n          \n        \n        =\n        (\n        \n          w\n          \n            j\n            k\n          \n          \n            l\n          \n        \n        )\n      \n    \n    {\\displaystyle W^{l}=(w_{jk}^{l})}\n  \n: the weights between layer \n  \n    \n      \n        l\n        −\n        1\n      \n    \n    {\\displaystyle l-1}\n  \n and \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n, where \n  \n    \n      \n        \n          w\n          \n            j\n            k\n          \n          \n            l\n          \n        \n      \n    \n    {\\displaystyle w_{jk}^{l}}\n  \n is the weight between the \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n-th node in layer \n  \n    \n      \n        l\n        −\n        1\n      \n    \n    {\\displaystyle l-1}\n  \n and the \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n-th node in layer \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n\n  \n    \n      \n        \n          f\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle f^{l}}\n  \n: activation functions at layer \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n\nFor classification the last layer is usually the logistic function for binary classification, and softmax (softargmax) for multi-class classification, while for the hidden layers this was traditionally a sigmoid function (logistic function or others) on each node (coordinate), but today is more varied, with rectifier (ramp, ReLU) being common.\n\n  \n    \n      \n        \n          a\n          \n            j\n          \n          \n            l\n          \n        \n      \n    \n    {\\displaystyle a_{j}^{l}}\n  \n: activation of the \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n-th node in layer \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n.\nIn the derivation of backpropagation, other intermediate quantities are used by introducing them as needed below. Bias terms are not treated specially since they correspond to a weight with a fixed input of 1. For backpropagation the specific loss function and activation functions do not matter as long as they and their derivatives can be evaluated efficiently. Traditional activation functions include sigmoid, tanh, and ReLU. Swish, Mish, and many others.\nThe overall network is a combination of function composition and matrix multiplication:\n\n  \n    \n      \n        g\n        (\n        x\n        )\n        :=\n        \n          f\n          \n            L\n          \n        \n        (\n        \n          W\n          \n            L\n          \n        \n        \n          f\n          \n            L\n            −\n            1\n          \n        \n        (\n        \n          W\n          \n            L\n            −\n            1\n          \n        \n        ⋯\n        \n          f\n          \n            1\n          \n        \n        (\n        \n          W\n          \n            1\n          \n        \n        x\n        )\n        ⋯\n        )\n        )\n      \n    \n    {\\displaystyle g(x):=f^{L}(W^{L}f^{L-1}(W^{L-1}\\cdots f^{1}(W^{1}x)\\cdots ))}\n  \n\nFor a training set there will be a set of input–output pairs, \n  \n    \n      \n        \n          {\n          \n            (\n            \n              x\n              \n                i\n              \n            \n            ,\n            \n              y\n              \n                i\n              \n            \n            )\n          \n          }\n        \n      \n    \n    {\\displaystyle \\left\\{(x_{i},y_{i})\\right\\}}\n  \n. For each input–output pair \n  \n    \n      \n        (\n        \n          x\n          \n            i\n          \n        \n        ,\n        \n          y\n          \n            i\n          \n        \n        )\n      \n    \n    {\\displaystyle (x_{i},y_{i})}\n  \n in the training set, the loss of the model on that pair is the cost of the difference between the predicted output \n  \n    \n      \n        g\n        (\n        \n          x\n          \n            i\n          \n        \n        )\n      \n    \n    {\\displaystyle g(x_{i})}\n  \n and the target output \n  \n    \n      \n        \n          y\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle y_{i}}\n  \n:\n\n  \n    \n      \n        C\n        (\n        \n          y\n          \n            i\n          \n        \n        ,\n        g\n        (\n        \n          x\n          \n            i\n          \n        \n        )\n        )\n      \n    \n    {\\displaystyle C(y_{i},g(x_{i}))}\n  \n\nNote the distinction: during model evaluation the weights are fixed while the inputs vary (and the target output may be unknown), and the network ends with the output layer (it does not include the loss function). During model training the input–output pair is fixed while the weights vary, and the network ends with the loss function.\nBackpropagation computes the gradient for a fixed input–output pair \n  \n    \n      \n        (\n        \n          x\n          \n            i\n          \n        \n        ,\n        \n          y\n          \n            i\n          \n        \n        )\n      \n    \n    {\\displaystyle (x_{i},y_{i})}\n  \n, where the weights \n  \n    \n      \n        \n          w\n          \n            j\n            k\n          \n          \n            l\n          \n        \n      \n    \n    {\\displaystyle w_{jk}^{l}}\n  \n can vary. Each individual component of the gradient, \n  \n    \n      \n        ∂\n        C\n        \n          /\n        \n        ∂\n        \n          w\n          \n            j\n            k\n          \n          \n            l\n          \n        \n        ,\n      \n    \n    {\\displaystyle \\partial C/\\partial w_{jk}^{l},}\n  \n can be computed by the chain rule; but doing this separately for each weight is inefficient. Backpropagation efficiently computes the gradient by avoiding duplicate calculations and not computing unnecessary intermediate values, by computing the gradient of each layer – specifically the gradient of the weighted input of each layer, denoted by \n  \n    \n      \n        \n          δ\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle \\delta ^{l}}\n  \n – from back to front.\nInformally, the key point is that since the only way a weight in \n  \n    \n      \n        \n          W\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle W^{l}}\n  \n affects the loss is through its effect on the next layer, and it does so linearly, \n  \n    \n      \n        \n          δ\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle \\delta ^{l}}\n  \n are the only data you need to compute the gradients of the weights at layer \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n, and then the gradients of weights of previous layer can be computed by \n  \n    \n      \n        \n          δ\n          \n            l\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle \\delta ^{l-1}}\n  \n and repeated recursively. This avoids inefficiency in two ways. First, it avoids duplication because when computing the gradient at layer \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n, it is unnecessary to recompute all derivatives on later layers \n  \n    \n      \n        l\n        +\n        1\n        ,\n        l\n        +\n        2\n        ,\n        …\n      \n    \n    {\\displaystyle l+1,l+2,\\ldots }\n  \n each time. Second, it avoids unnecessary intermediate calculations, because at each stage it directly computes the gradient of the weights with respect to the ultimate output (the loss), rather than unnecessarily computing the derivatives of the values of hidden layers with respect to changes in weights \n  \n    \n      \n        ∂\n        \n          a\n          \n            \n              j\n              ′\n            \n          \n          \n            \n              l\n              ′\n            \n          \n        \n        \n          /\n        \n        ∂\n        \n          w\n          \n            j\n            k\n          \n          \n            l\n          \n        \n      \n    \n    {\\displaystyle \\partial a_{j'}^{l'}/\\partial w_{jk}^{l}}\n  \n.\nBackpropagation can be expressed for simple feedforward networks in terms of matrix multiplication, or more generally in terms of the adjoint graph.\n\n\n== Matrix multiplication ==\nFor the basic case of a feedforward network, where nodes in each layer are connected only to nodes in the immediate next layer (without skipping any layers), and there is a loss function that computes a scalar loss for the final output, backpropagation can be understood simply by matrix multiplication. Essentially, backpropagation evaluates the expression for the derivative of the cost function as a product of derivatives between each layer from right to left – \"backwards\" – with the gradient of the weights between each layer being a simple modification of the partial products (the \"backwards propagated error\").\nGiven an input–output pair \n  \n    \n      \n        (\n        x\n        ,\n        y\n        )\n      \n    \n    {\\displaystyle (x,y)}\n  \n, the loss is:\n\n  \n    \n      \n        C\n        (\n        y\n        ,\n        \n          f\n          \n            L\n          \n        \n        (\n        \n          W\n          \n            L\n          \n        \n        \n          f\n          \n            L\n            −\n            1\n          \n        \n        (\n        \n          W\n          \n            L\n            −\n            1\n          \n        \n        ⋯\n        \n          f\n          \n            2\n          \n        \n        (\n        \n          W\n          \n            2\n          \n        \n        \n          f\n          \n            1\n          \n        \n        (\n        \n          W\n          \n            1\n          \n        \n        x\n        )\n        )\n        ⋯\n        )\n        )\n        )\n      \n    \n    {\\displaystyle C(y,f^{L}(W^{L}f^{L-1}(W^{L-1}\\cdots f^{2}(W^{2}f^{1}(W^{1}x))\\cdots )))}\n  \n\nTo compute this, one starts with the input \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n and works forward; denote the weighted input of each hidden layer as \n  \n    \n      \n        \n          z\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle z^{l}}\n  \n and the output of hidden layer \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n as the activation \n  \n    \n      \n        \n          a\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle a^{l}}\n  \n. For backpropagation, the activation \n  \n    \n      \n        \n          a\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle a^{l}}\n  \n as well as the derivatives \n  \n    \n      \n        (\n        \n          f\n          \n            l\n          \n        \n        \n          )\n          ′\n        \n      \n    \n    {\\displaystyle (f^{l})'}\n  \n (evaluated at \n  \n    \n      \n        \n          z\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle z^{l}}\n  \n) must be cached for use during the backwards pass.\nThe derivative of the loss in terms of the inputs is given by the chain rule; note that each term is a total derivative, evaluated at the value of the network (at each node) on the input \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n:\n\n  \n    \n      \n        \n          \n            \n              d\n              C\n            \n            \n              d\n              \n                a\n                \n                  L\n                \n              \n            \n          \n        \n        ⋅\n        \n          \n            \n              d\n              \n                a\n                \n                  L\n                \n              \n            \n            \n              d\n              \n                z\n                \n                  L\n                \n              \n            \n          \n        \n        ⋅\n        \n          \n            \n              d\n              \n                z\n                \n                  L\n                \n              \n            \n            \n              d\n              \n                a\n                \n                  L\n                  −\n                  1\n                \n              \n            \n          \n        \n        ⋅\n        \n          \n            \n              d\n              \n                a\n                \n                  L\n                  −\n                  1\n                \n              \n            \n            \n              d\n              \n                z\n                \n                  L\n                  −\n                  1\n                \n              \n            \n          \n        \n        ⋅\n        \n          \n            \n              d\n              \n                z\n                \n                  L\n                  −\n                  1\n                \n              \n            \n            \n              d\n              \n                a\n                \n                  L\n                  −\n                  2\n                \n              \n            \n          \n        \n        ⋅\n        …\n        ⋅\n        \n          \n            \n              d\n              \n                a\n                \n                  1\n                \n              \n            \n            \n              d\n              \n                z\n                \n                  1\n                \n              \n            \n          \n        \n        ⋅\n        \n          \n            \n              ∂\n              \n                z\n                \n                  1\n                \n              \n            \n            \n              ∂\n              x\n            \n          \n        \n        ,\n      \n    \n    {\\displaystyle {\\frac {dC}{da^{L}}}\\cdot {\\frac {da^{L}}{dz^{L}}}\\cdot {\\frac {dz^{L}}{da^{L-1}}}\\cdot {\\frac {da^{L-1}}{dz^{L-1}}}\\cdot {\\frac {dz^{L-1}}{da^{L-2}}}\\cdot \\ldots \\cdot {\\frac {da^{1}}{dz^{1}}}\\cdot {\\frac {\\partial z^{1}}{\\partial x}},}\n  \n\nwhere \n  \n    \n      \n        \n          \n            \n              d\n              \n                a\n                \n                  L\n                \n              \n            \n            \n              d\n              \n                z\n                \n                  L\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\frac {da^{L}}{dz^{L}}}}\n  \n is a diagonal matrix.\nThese terms are: the derivative of the loss function; the derivatives of the activation functions; and the matrices of weights:\n\n  \n    \n      \n        \n          \n            \n              d\n              C\n            \n            \n              d\n              \n                a\n                \n                  L\n                \n              \n            \n          \n        \n        ∘\n        (\n        \n          f\n          \n            L\n          \n        \n        \n          )\n          ′\n        \n        ⋅\n        \n          W\n          \n            L\n          \n        \n        ∘\n        (\n        \n          f\n          \n            L\n            −\n            1\n          \n        \n        \n          )\n          ′\n        \n        ⋅\n        \n          W\n          \n            L\n            −\n            1\n          \n        \n        ∘\n        ⋯\n        ∘\n        (\n        \n          f\n          \n            1\n          \n        \n        \n          )\n          ′\n        \n        ⋅\n        \n          W\n          \n            1\n          \n        \n        .\n      \n    \n    {\\displaystyle {\\frac {dC}{da^{L}}}\\circ (f^{L})'\\cdot W^{L}\\circ (f^{L-1})'\\cdot W^{L-1}\\circ \\cdots \\circ (f^{1})'\\cdot W^{1}.}\n  \n\nThe gradient \n  \n    \n      \n        ∇\n      \n    \n    {\\displaystyle \\nabla }\n  \n is the transpose of the derivative of the output in terms of the input, so the matrices are transposed and the order of multiplication is reversed, but the entries are the same:\n\n  \n    \n      \n        \n          ∇\n          \n            x\n          \n        \n        C\n        =\n        (\n        \n          W\n          \n            1\n          \n        \n        \n          )\n          \n            T\n          \n        \n        ⋅\n        (\n        \n          f\n          \n            1\n          \n        \n        \n          )\n          ′\n        \n        ∘\n        …\n        ∘\n        (\n        \n          W\n          \n            L\n            −\n            1\n          \n        \n        \n          )\n          \n            T\n          \n        \n        ⋅\n        (\n        \n          f\n          \n            L\n            −\n            1\n          \n        \n        \n          )\n          ′\n        \n        ∘\n        (\n        \n          W\n          \n            L\n          \n        \n        \n          )\n          \n            T\n          \n        \n        ⋅\n        (\n        \n          f\n          \n            L\n          \n        \n        \n          )\n          ′\n        \n        ∘\n        \n          ∇\n          \n            \n              a\n              \n                L\n              \n            \n          \n        \n        C\n        .\n      \n    \n    {\\displaystyle \\nabla _{x}C=(W^{1})^{T}\\cdot (f^{1})'\\circ \\ldots \\circ (W^{L-1})^{T}\\cdot (f^{L-1})'\\circ (W^{L})^{T}\\cdot (f^{L})'\\circ \\nabla _{a^{L}}C.}\n  \n\nBackpropagation then consists essentially of evaluating this expression from right to left (equivalently, multiplying the previous expression for the derivative from left to right), computing the gradient at each layer on the way; there is an added step, because the gradient of the weights is not just a subexpression: there's an extra multiplication.\nIntroducing the auxiliary quantity \n  \n    \n      \n        \n          δ\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle \\delta ^{l}}\n  \n for the partial products (multiplying from right to left), interpreted as the \"error at level \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n\" and defined as the gradient of the input values at level \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n:\n\n  \n    \n      \n        \n          δ\n          \n            l\n          \n        \n        :=\n        (\n        \n          f\n          \n            l\n          \n        \n        \n          )\n          ′\n        \n        ∘\n        (\n        \n          W\n          \n            l\n            +\n            1\n          \n        \n        \n          )\n          \n            T\n          \n        \n        ⋅\n        (\n        \n          f\n          \n            l\n            +\n            1\n          \n        \n        \n          )\n          ′\n        \n        ∘\n        ⋯\n        ∘\n        (\n        \n          W\n          \n            L\n            −\n            1\n          \n        \n        \n          )\n          \n            T\n          \n        \n        ⋅\n        (\n        \n          f\n          \n            L\n            −\n            1\n          \n        \n        \n          )\n          ′\n        \n        ∘\n        (\n        \n          W\n          \n            L\n          \n        \n        \n          )\n          \n            T\n          \n        \n        ⋅\n        (\n        \n          f\n          \n            L\n          \n        \n        \n          )\n          ′\n        \n        ∘\n        \n          ∇\n          \n            \n              a\n              \n                L\n              \n            \n          \n        \n        C\n        .\n      \n    \n    {\\displaystyle \\delta ^{l}:=(f^{l})'\\circ (W^{l+1})^{T}\\cdot (f^{l+1})'\\circ \\cdots \\circ (W^{L-1})^{T}\\cdot (f^{L-1})'\\circ (W^{L})^{T}\\cdot (f^{L})'\\circ \\nabla _{a^{L}}C.}\n  \n\nNote that \n  \n    \n      \n        \n          δ\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle \\delta ^{l}}\n  \n is a vector, of length equal to the number of nodes in level \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n; each component is interpreted as the \"cost attributable to (the value of) that node\".\nThe gradient of the weights in layer \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n is then:\n\n  \n    \n      \n        \n          ∇\n          \n            \n              W\n              \n                l\n              \n            \n          \n        \n        C\n        =\n        \n          δ\n          \n            l\n          \n        \n        (\n        \n          a\n          \n            l\n            −\n            1\n          \n        \n        \n          )\n          \n            T\n          \n        \n        .\n      \n    \n    {\\displaystyle \\nabla _{W^{l}}C=\\delta ^{l}(a^{l-1})^{T}.}\n  \n\nThe factor of \n  \n    \n      \n        \n          a\n          \n            l\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle a^{l-1}}\n  \n is because the weights \n  \n    \n      \n        \n          W\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle W^{l}}\n  \n between level \n  \n    \n      \n        l\n        −\n        1\n      \n    \n    {\\displaystyle l-1}\n  \n and \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n affect level \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n proportionally to the inputs (activations): the inputs are fixed, the weights vary.\nThe \n  \n    \n      \n        \n          δ\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle \\delta ^{l}}\n  \n can easily be computed recursively, going from right to left, as:\n\n  \n    \n      \n        \n          δ\n          \n            l\n            −\n            1\n          \n        \n        :=\n        (\n        \n          f\n          \n            l\n            −\n            1\n          \n        \n        \n          )\n          ′\n        \n        ∘\n        (\n        \n          W\n          \n            l\n          \n        \n        \n          )\n          \n            T\n          \n        \n        ⋅\n        \n          δ\n          \n            l\n          \n        \n        .\n      \n    \n    {\\displaystyle \\delta ^{l-1}:=(f^{l-1})'\\circ (W^{l})^{T}\\cdot \\delta ^{l}.}\n  \n\nThe gradients of the weights can thus be computed using a few matrix multiplications for each level; this is backpropagation.\nCompared with naively computing forwards (using the \n  \n    \n      \n        \n          δ\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle \\delta ^{l}}\n  \n for illustration):\n\n  \n    \n      \n        \n          \n            \n              \n                \n                  δ\n                  \n                    1\n                  \n                \n              \n              \n                \n                =\n                (\n                \n                  f\n                  \n                    1\n                  \n                \n                \n                  )\n                  ′\n                \n                ∘\n                (\n                \n                  W\n                  \n                    2\n                  \n                \n                \n                  )\n                  \n                    T\n                  \n                \n                ⋅\n                (\n                \n                  f\n                  \n                    2\n                  \n                \n                \n                  )\n                  ′\n                \n                ∘\n                ⋯\n                ∘\n                (\n                \n                  W\n                  \n                    L\n                    −\n                    1\n                  \n                \n                \n                  )\n                  \n                    T\n                  \n                \n                ⋅\n                (\n                \n                  f\n                  \n                    L\n                    −\n                    1\n                  \n                \n                \n                  )\n                  ′\n                \n                ∘\n                (\n                \n                  W\n                  \n                    L\n                  \n                \n                \n                  )\n                  \n                    T\n                  \n                \n                ⋅\n                (\n                \n                  f\n                  \n                    L\n                  \n                \n                \n                  )\n                  ′\n                \n                ∘\n                \n                  ∇\n                  \n                    \n                      a\n                      \n                        L\n                      \n                    \n                  \n                \n                C\n              \n            \n            \n              \n                \n                  δ\n                  \n                    2\n                  \n                \n              \n              \n                \n                =\n                (\n                \n                  f\n                  \n                    2\n                  \n                \n                \n                  )\n                  ′\n                \n                ∘\n                ⋯\n                ∘\n                (\n                \n                  W\n                  \n                    L\n                    −\n                    1\n                  \n                \n                \n                  )\n                  \n                    T\n                  \n                \n                ⋅\n                (\n                \n                  f\n                  \n                    L\n                    −\n                    1\n                  \n                \n                \n                  )\n                  ′\n                \n                ∘\n                (\n                \n                  W\n                  \n                    L\n                  \n                \n                \n                  )\n                  \n                    T\n                  \n                \n                ⋅\n                (\n                \n                  f\n                  \n                    L\n                  \n                \n                \n                  )\n                  ′\n                \n                ∘\n                \n                  ∇\n                  \n                    \n                      a\n                      \n                        L\n                      \n                    \n                  \n                \n                C\n              \n            \n            \n              \n              \n                \n                ⋮\n              \n            \n            \n              \n                \n                  δ\n                  \n                    L\n                    −\n                    1\n                  \n                \n              \n              \n                \n                =\n                (\n                \n                  f\n                  \n                    L\n                    −\n                    1\n                  \n                \n                \n                  )\n                  ′\n                \n                ∘\n                (\n                \n                  W\n                  \n                    L\n                  \n                \n                \n                  )\n                  \n                    T\n                  \n                \n                ⋅\n                (\n                \n                  f\n                  \n                    L\n                  \n                \n                \n                  )\n                  ′\n                \n                ∘\n                \n                  ∇\n                  \n                    \n                      a\n                      \n                        L\n                      \n                    \n                  \n                \n                C\n              \n            \n            \n              \n                \n                  δ\n                  \n                    L\n                  \n                \n              \n              \n                \n                =\n                (\n                \n                  f\n                  \n                    L\n                  \n                \n                \n                  )\n                  ′\n                \n                ∘\n                \n                  ∇\n                  \n                    \n                      a\n                      \n                        L\n                      \n                    \n                  \n                \n                C\n                ,\n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\begin{aligned}\\delta ^{1}&=(f^{1})'\\circ (W^{2})^{T}\\cdot (f^{2})'\\circ \\cdots \\circ (W^{L-1})^{T}\\cdot (f^{L-1})'\\circ (W^{L})^{T}\\cdot (f^{L})'\\circ \\nabla _{a^{L}}C\\\\\\delta ^{2}&=(f^{2})'\\circ \\cdots \\circ (W^{L-1})^{T}\\cdot (f^{L-1})'\\circ (W^{L})^{T}\\cdot (f^{L})'\\circ \\nabla _{a^{L}}C\\\\&\\vdots \\\\\\delta ^{L-1}&=(f^{L-1})'\\circ (W^{L})^{T}\\cdot (f^{L})'\\circ \\nabla _{a^{L}}C\\\\\\delta ^{L}&=(f^{L})'\\circ \\nabla _{a^{L}}C,\\end{aligned}}}\n  \n\nThere are two key differences with backpropagation:\n\nComputing \n  \n    \n      \n        \n          δ\n          \n            l\n            −\n            1\n          \n        \n      \n    \n    {\\displaystyle \\delta ^{l-1}}\n  \n in terms of \n  \n    \n      \n        \n          δ\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle \\delta ^{l}}\n  \n avoids the obvious duplicate multiplication of layers \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n and beyond.\nMultiplying starting from \n  \n    \n      \n        \n          ∇\n          \n            \n              a\n              \n                L\n              \n            \n          \n        \n        C\n      \n    \n    {\\displaystyle \\nabla _{a^{L}}C}\n  \n – propagating the error backwards – means that each step simply multiplies a vector (\n  \n    \n      \n        \n          δ\n          \n            l\n          \n        \n      \n    \n    {\\displaystyle \\delta ^{l}}\n  \n) by the matrices of weights \n  \n    \n      \n        (\n        \n          W\n          \n            l\n          \n        \n        \n          )\n          \n            T\n          \n        \n      \n    \n    {\\displaystyle (W^{l})^{T}}\n  \n and derivatives of activations \n  \n    \n      \n        (\n        \n          f\n          \n            l\n            −\n            1\n          \n        \n        \n          )\n          ′\n        \n      \n    \n    {\\displaystyle (f^{l-1})'}\n  \n. By contrast, multiplying forwards, starting from the changes at an earlier layer, means that each multiplication multiplies a matrix by a matrix. This is much more expensive, and corresponds to tracking every possible path of a change in one layer \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n forward to changes in the layer \n  \n    \n      \n        l\n        +\n        2\n      \n    \n    {\\displaystyle l+2}\n  \n (for multiplying \n  \n    \n      \n        \n          W\n          \n            l\n            +\n            1\n          \n        \n      \n    \n    {\\displaystyle W^{l+1}}\n  \n by \n  \n    \n      \n        \n          W\n          \n            l\n            +\n            2\n          \n        \n      \n    \n    {\\displaystyle W^{l+2}}\n  \n, with additional multiplications for the derivatives of the activations), which unnecessarily computes the intermediate quantities of how weight changes affect the values of hidden nodes.\n\n\n== Adjoint graph ==\n\nFor more general graphs, and other advanced variations, backpropagation can be understood in terms of automatic differentiation, where backpropagation is a special case of reverse accumulation (or \"reverse mode\").\n\n\n== Intuition ==\n\n\n=== Motivation ===\nThe goal of any supervised learning algorithm is to find a function that best maps a set of inputs to their correct output. The motivation for backpropagation is to train a multi-layered neural network such that it can learn the appropriate internal representations to allow it to learn any arbitrary mapping of input to output.\n\n\n=== Learning as an optimization problem ===\nTo understand the mathematical derivation of the backpropagation algorithm, it helps to first develop some intuition about the relationship between the actual output of a neuron and the correct output for a particular training example. Consider a simple neural network with two input units, one output unit and no hidden units, and in which each neuron uses a linear output (unlike most work on neural networks, in which mapping from inputs to outputs is non-linear) that is the weighted sum of its input. \nInitially, before training, the weights will be set randomly. Then the neuron learns from training examples, which in this case consist of a set of tuples \n  \n    \n      \n        (\n        \n          x\n          \n            1\n          \n        \n        ,\n        \n          x\n          \n            2\n          \n        \n        ,\n        t\n        )\n      \n    \n    {\\displaystyle (x_{1},x_{2},t)}\n  \n where \n  \n    \n      \n        \n          x\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle x_{1}}\n  \n and \n  \n    \n      \n        \n          x\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle x_{2}}\n  \n are the inputs to the network and t is the correct output (the output the network should produce given those inputs, when it has been trained). The initial network, given \n  \n    \n      \n        \n          x\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle x_{1}}\n  \n and \n  \n    \n      \n        \n          x\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle x_{2}}\n  \n, will compute an output y that likely differs from t (given random weights). A loss function \n  \n    \n      \n        L\n        (\n        t\n        ,\n        y\n        )\n      \n    \n    {\\displaystyle L(t,y)}\n  \n is used for measuring the discrepancy between the target output t and the computed output y. For regression analysis problems the squared error can be used as a loss function, for classification the categorical cross-entropy can be used.\nAs an example consider a regression problem using the square error as a loss:\n\n  \n    \n      \n        L\n        (\n        t\n        ,\n        y\n        )\n        =\n        (\n        t\n        −\n        y\n        \n          )\n          \n            2\n          \n        \n        =\n        E\n        ,\n      \n    \n    {\\displaystyle L(t,y)=(t-y)^{2}=E,}\n  \n\nwhere E is the discrepancy or error.\n\nConsider the network on a single training case: \n  \n    \n      \n        (\n        1\n        ,\n        1\n        ,\n        0\n        )\n      \n    \n    {\\displaystyle (1,1,0)}\n  \n. Thus, the input \n  \n    \n      \n        \n          x\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle x_{1}}\n  \n and \n  \n    \n      \n        \n          x\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle x_{2}}\n  \n are 1 and 1 respectively and the correct output, t is 0. Now if the relation is plotted between the network's output y on the horizontal axis and the error E on the vertical axis, the result is a parabola. The minimum of the parabola corresponds to the output y which minimizes the error E. For a single training case, the minimum also touches the horizontal axis, which means the error will be zero and the network can produce an output y that exactly matches the target output t. Therefore, the problem of mapping inputs to outputs can be reduced to an optimization problem of finding a function that will produce the minimal error. \nHowever, the output of a neuron depends on the weighted sum of all its inputs:\n\n  \n    \n      \n        y\n        =\n        \n          x\n          \n            1\n          \n        \n        \n          w\n          \n            1\n          \n        \n        +\n        \n          x\n          \n            2\n          \n        \n        \n          w\n          \n            2\n          \n        \n        ,\n      \n    \n    {\\displaystyle y=x_{1}w_{1}+x_{2}w_{2},}\n  \n\nwhere \n  \n    \n      \n        \n          w\n          \n            1\n          \n        \n      \n    \n    {\\displaystyle w_{1}}\n  \n and \n  \n    \n      \n        \n          w\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle w_{2}}\n  \n are the weights on the connection from the input units to the output unit. Therefore, the error also depends on the incoming weights to the neuron, which is ultimately what needs to be changed in the network to enable learning.\nIn this example, upon injecting the training data \n  \n    \n      \n        (\n        1\n        ,\n        1\n        ,\n        0\n        )\n      \n    \n    {\\displaystyle (1,1,0)}\n  \n, the loss function becomes\n\n  \n    \n      \n        E\n        =\n        (\n        t\n        −\n        y\n        \n          )\n          \n            2\n          \n        \n        =\n        \n          y\n          \n            2\n          \n        \n        =\n        (\n        \n          x\n          \n            1\n          \n        \n        \n          w\n          \n            1\n          \n        \n        +\n        \n          x\n          \n            2\n          \n        \n        \n          w\n          \n            2\n          \n        \n        \n          )\n          \n            2\n          \n        \n        =\n        (\n        \n          w\n          \n            1\n          \n        \n        +\n        \n          w\n          \n            2\n          \n        \n        \n          )\n          \n            2\n          \n        \n        .\n      \n    \n    {\\displaystyle E=(t-y)^{2}=y^{2}=(x_{1}w_{1}+x_{2}w_{2})^{2}=(w_{1}+w_{2})^{2}.}\n  \n\nThen, the loss function \n  \n    \n      \n        E\n      \n    \n    {\\displaystyle E}\n  \n takes the form of a parabolic cylinder with its base directed along \n  \n    \n      \n        \n          w\n          \n            1\n          \n        \n        =\n        −\n        \n          w\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle w_{1}=-w_{2}}\n  \n. Since all sets of weights that satisfy \n  \n    \n      \n        \n          w\n          \n            1\n          \n        \n        =\n        −\n        \n          w\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle w_{1}=-w_{2}}\n  \n minimize the loss function, in this case additional constraints are required to converge to a unique solution. Additional constraints could either be generated by setting specific conditions to the weights, or by injecting additional training data.\nOne commonly used algorithm to find the set of weights that minimizes the error is gradient descent. By backpropagation, the steepest descent direction is calculated of the loss function versus the present synaptic weights. Then, the weights can be modified along the steepest descent direction, and the error is minimized in an efficient way.\n\n\n== Derivation ==\nThe gradient descent method involves calculating the derivative of the loss function with respect to the weights of the network. This is normally done using backpropagation. Assuming one output neuron, the squared error function is\n\n  \n    \n      \n        E\n        =\n        L\n        (\n        t\n        ,\n        y\n        )\n      \n    \n    {\\displaystyle E=L(t,y)}\n  \n\nwhere\n\n  \n    \n      \n        L\n      \n    \n    {\\displaystyle L}\n  \n is the loss for the output \n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n and target value \n  \n    \n      \n        t\n      \n    \n    {\\displaystyle t}\n  \n,\n\n  \n    \n      \n        t\n      \n    \n    {\\displaystyle t}\n  \n is the target output for a training sample, and\n\n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n is the actual output of the output neuron.\nIn this section, the order of the weight indexes are reversed relative to the prior section: \n  \n    \n      \n        \n          w\n          \n            i\n            j\n          \n        \n      \n    \n    {\\displaystyle w_{ij}}\n  \n is weight from the \n  \n    \n      \n        i\n      \n    \n    {\\displaystyle i}\n  \nth to the\n\n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \nth unit.  For each neuron \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n, its output \n  \n    \n      \n        \n          o\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle o_{j}}\n  \n is defined as\n\n  \n    \n      \n        \n          o\n          \n            j\n          \n        \n        =\n        φ\n        (\n        \n          \n            net\n          \n          \n            j\n          \n        \n        )\n        =\n        φ\n        \n          (\n          \n            \n              ∑\n              \n                k\n                =\n                1\n              \n              \n                n\n              \n            \n            \n              w\n              \n                k\n                j\n              \n            \n            \n              x\n              \n                k\n              \n            \n          \n          )\n        \n        ,\n      \n    \n    {\\displaystyle o_{j}=\\varphi ({\\text{net}}_{j})=\\varphi \\left(\\sum _{k=1}^{n}w_{kj}x_{k}\\right),}\n  \n\nwhere the activation function \n  \n    \n      \n        φ\n      \n    \n    {\\displaystyle \\varphi }\n  \n is non-linear and differentiable over the activation region (the ReLU is not differentiable at one point). A historically used activation function is the logistic function:\n\n  \n    \n      \n        φ\n        (\n        z\n        )\n        =\n        \n          \n            1\n            \n              1\n              +\n              \n                e\n                \n                  −\n                  z\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle \\varphi (z)={\\frac {1}{1+e^{-z}}}}\n  \n\nwhich has a convenient derivative of:\n\n  \n    \n      \n        \n          \n            \n              d\n              φ\n            \n            \n              d\n              z\n            \n          \n        \n        =\n        φ\n        (\n        z\n        )\n        (\n        1\n        −\n        φ\n        (\n        z\n        )\n        )\n      \n    \n    {\\displaystyle {\\frac {d\\varphi }{dz}}=\\varphi (z)(1-\\varphi (z))}\n  \n\nThe input \n  \n    \n      \n        \n          \n            net\n          \n          \n            j\n          \n        \n      \n    \n    {\\displaystyle {\\text{net}}_{j}}\n  \n to a neuron is the weighted sum of outputs \n  \n    \n      \n        \n          o\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle o_{k}}\n  \n of previous neurons. If the neuron is in the first layer after the input layer, the \n  \n    \n      \n        \n          o\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle o_{k}}\n  \n of the input layer are simply the inputs \n  \n    \n      \n        \n          x\n          \n            k\n          \n        \n      \n    \n    {\\displaystyle x_{k}}\n  \n to the network. The number of input units to the neuron is \n  \n    \n      \n        n\n      \n    \n    {\\displaystyle n}\n  \n. The variable \n  \n    \n      \n        \n          w\n          \n            k\n            j\n          \n        \n      \n    \n    {\\displaystyle w_{kj}}\n  \n denotes the weight between neuron \n  \n    \n      \n        k\n      \n    \n    {\\displaystyle k}\n  \n of the previous layer and neuron \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n of the current layer.\n\n\n=== Finding the derivative of the error ===\n\nCalculating the partial derivative of the error with respect to a weight \n  \n    \n      \n        \n          w\n          \n            i\n            j\n          \n        \n      \n    \n    {\\displaystyle w_{ij}}\n  \n is done using the chain rule twice:\n\nIn the last factor of the right-hand side of the above, only one term in the sum \n  \n    \n      \n        \n          \n            net\n          \n          \n            j\n          \n        \n      \n    \n    {\\displaystyle {\\text{net}}_{j}}\n  \n depends on \n  \n    \n      \n        \n          w\n          \n            i\n            j\n          \n        \n      \n    \n    {\\displaystyle w_{ij}}\n  \n, so that\n\nIf the neuron is in the first layer after the input layer, \n  \n    \n      \n        \n          o\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle o_{i}}\n  \n is just \n  \n    \n      \n        \n          x\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle x_{i}}\n  \n.\nThe derivative of the output of neuron \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n with respect to its input is simply the partial derivative of the activation function:\n\nwhich for the logistic activation function \n\n  \n    \n      \n        \n          \n            \n              ∂\n              \n                o\n                \n                  j\n                \n              \n            \n            \n              ∂\n              \n                \n                  net\n                \n                \n                  j\n                \n              \n            \n          \n        \n        =\n        \n          \n            ∂\n            \n              ∂\n              \n                \n                  net\n                \n                \n                  j\n                \n              \n            \n          \n        \n        φ\n        (\n        \n          \n            net\n          \n          \n            j\n          \n        \n        )\n        =\n        φ\n        (\n        \n          \n            net\n          \n          \n            j\n          \n        \n        )\n        (\n        1\n        −\n        φ\n        (\n        \n          \n            net\n          \n          \n            j\n          \n        \n        )\n        )\n        =\n        \n          o\n          \n            j\n          \n        \n        (\n        1\n        −\n        \n          o\n          \n            j\n          \n        \n        )\n      \n    \n    {\\displaystyle {\\frac {\\partial o_{j}}{\\partial {\\text{net}}_{j}}}={\\frac {\\partial }{\\partial {\\text{net}}_{j}}}\\varphi ({\\text{net}}_{j})=\\varphi ({\\text{net}}_{j})(1-\\varphi ({\\text{net}}_{j}))=o_{j}(1-o_{j})}\n  \n\nThis is the reason why backpropagation requires that the activation function be differentiable. (Nevertheless, the ReLU activation function, which is non-differentiable at 0, has become quite popular, e.g. in AlexNet)\nThe first factor is straightforward to evaluate if the neuron is in the output layer, because then \n  \n    \n      \n        \n          o\n          \n            j\n          \n        \n        =\n        y\n      \n    \n    {\\displaystyle o_{j}=y}\n  \n and\n\nIf half of the square error is used as loss function we can rewrite it as\n\n  \n    \n      \n        \n          \n            \n              ∂\n              E\n            \n            \n              ∂\n              \n                o\n                \n                  j\n                \n              \n            \n          \n        \n        =\n        \n          \n            \n              ∂\n              E\n            \n            \n              ∂\n              y\n            \n          \n        \n        =\n        \n          \n            ∂\n            \n              ∂\n              y\n            \n          \n        \n        \n          \n            1\n            2\n          \n        \n        (\n        t\n        −\n        y\n        \n          )\n          \n            2\n          \n        \n        =\n        y\n        −\n        t\n      \n    \n    {\\displaystyle {\\frac {\\partial E}{\\partial o_{j}}}={\\frac {\\partial E}{\\partial y}}={\\frac {\\partial }{\\partial y}}{\\frac {1}{2}}(t-y)^{2}=y-t}\n  \n\nHowever, if \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n is in an arbitrary inner layer of the network, finding the derivative \n  \n    \n      \n        E\n      \n    \n    {\\displaystyle E}\n  \n with respect to \n  \n    \n      \n        \n          o\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle o_{j}}\n  \n is less obvious.\nConsidering \n  \n    \n      \n        E\n      \n    \n    {\\displaystyle E}\n  \n as a function with the inputs being all neurons \n  \n    \n      \n        L\n        =\n        {\n        u\n        ,\n        v\n        ,\n        …\n        ,\n        w\n        }\n      \n    \n    {\\displaystyle L=\\{u,v,\\dots ,w\\}}\n  \n receiving input from neuron \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n,\n\n  \n    \n      \n        \n          \n            \n              ∂\n              E\n              (\n              \n                o\n                \n                  j\n                \n              \n              )\n            \n            \n              ∂\n              \n                o\n                \n                  j\n                \n              \n            \n          \n        \n        =\n        \n          \n            \n              ∂\n              E\n              (\n              \n                \n                  n\n                  e\n                  t\n                \n                \n                  u\n                \n              \n              ,\n              \n                \n                  net\n                \n                \n                  v\n                \n              \n              ,\n              …\n              ,\n              \n                \n                  n\n                  e\n                  t\n                \n                \n                  w\n                \n              \n              )\n            \n            \n              ∂\n              \n                o\n                \n                  j\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\frac {\\partial E(o_{j})}{\\partial o_{j}}}={\\frac {\\partial E(\\mathrm {net} _{u},{\\text{net}}_{v},\\dots ,\\mathrm {net} _{w})}{\\partial o_{j}}}}\n  \n\nand taking the total derivative with respect to \n  \n    \n      \n        \n          o\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle o_{j}}\n  \n, a recursive expression for the derivative is obtained:\n\nTherefore, the derivative with respect to \n  \n    \n      \n        \n          o\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle o_{j}}\n  \n can be calculated if all the derivatives with respect to the outputs \n  \n    \n      \n        \n          o\n          \n            ℓ\n          \n        \n      \n    \n    {\\displaystyle o_{\\ell }}\n  \n of the next layer – the ones closer to the output neuron – are known. [Note, if any of the neurons in set \n  \n    \n      \n        L\n      \n    \n    {\\displaystyle L}\n  \n were not connected to neuron \n  \n    \n      \n        j\n      \n    \n    {\\displaystyle j}\n  \n, they would be independent of \n  \n    \n      \n        \n          w\n          \n            i\n            j\n          \n        \n      \n    \n    {\\displaystyle w_{ij}}\n  \n and the corresponding partial derivative under the summation would vanish to 0.]\nSubstituting Eq. 2, Eq. 3 Eq.4 and Eq. 5 in Eq. 1 we obtain:\n\n  \n    \n      \n        \n          \n            \n              ∂\n              E\n            \n            \n              ∂\n              \n                w\n                \n                  i\n                  j\n                \n              \n            \n          \n        \n        =\n        \n          \n            \n              ∂\n              E\n            \n            \n              ∂\n              \n                o\n                \n                  j\n                \n              \n            \n          \n        \n        \n          \n            \n              ∂\n              \n                o\n                \n                  j\n                \n              \n            \n            \n              ∂\n              \n                \n                  net\n                \n                \n                  j\n                \n              \n            \n          \n        \n        \n          \n            \n              ∂\n              \n                \n                  net\n                \n                \n                  j\n                \n              \n            \n            \n              ∂\n              \n                w\n                \n                  i\n                  j\n                \n              \n            \n          \n        \n        =\n        \n          \n            \n              ∂\n              E\n            \n            \n              ∂\n              \n                o\n                \n                  j\n                \n              \n            \n          \n        \n        \n          \n            \n              ∂\n              \n                o\n                \n                  j\n                \n              \n            \n            \n              ∂\n              \n                \n                  net\n                \n                \n                  j\n                \n              \n            \n          \n        \n        \n          o\n          \n            i\n          \n        \n      \n    \n    {\\displaystyle {\\frac {\\partial E}{\\partial w_{ij}}}={\\frac {\\partial E}{\\partial o_{j}}}{\\frac {\\partial o_{j}}{\\partial {\\text{net}}_{j}}}{\\frac {\\partial {\\text{net}}_{j}}{\\partial w_{ij}}}={\\frac {\\partial E}{\\partial o_{j}}}{\\frac {\\partial o_{j}}{\\partial {\\text{net}}_{j}}}o_{i}}\n  \n\n  \n    \n      \n        \n          \n            \n              ∂\n              E\n            \n            \n              ∂\n              \n                w\n                \n                  i\n                  j\n                \n              \n            \n          \n        \n        =\n        \n          o\n          \n            i\n          \n        \n        \n          δ\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle {\\frac {\\partial E}{\\partial w_{ij}}}=o_{i}\\delta _{j}}\n  \n\nwith\n\n  \n    \n      \n        \n          δ\n          \n            j\n          \n        \n        =\n        \n          \n            \n              ∂\n              E\n            \n            \n              ∂\n              \n                o\n                \n                  j\n                \n              \n            \n          \n        \n        \n          \n            \n              ∂\n              \n                o\n                \n                  j\n                \n              \n            \n            \n              ∂\n              \n                \n                  net\n                \n                \n                  j\n                \n              \n            \n          \n        \n        =\n        \n          \n            {\n            \n              \n                \n                  \n                    \n                      \n                        ∂\n                        L\n                        (\n                        t\n                        ,\n                        \n                          o\n                          \n                            j\n                          \n                        \n                        )\n                      \n                      \n                        ∂\n                        \n                          o\n                          \n                            j\n                          \n                        \n                      \n                    \n                  \n                  \n                    \n                      \n                        d\n                        φ\n                        (\n                        \n                          \n                            net\n                          \n                          \n                            j\n                          \n                        \n                        )\n                      \n                      \n                        d\n                        \n                          \n                            net\n                          \n                          \n                            j\n                          \n                        \n                      \n                    \n                  \n                \n                \n                  \n                    if \n                  \n                  j\n                  \n                     is an output neuron,\n                  \n                \n              \n              \n                \n                  (\n                  \n                    ∑\n                    \n                      ℓ\n                      ∈\n                      L\n                    \n                  \n                  \n                    w\n                    \n                      j\n                      ℓ\n                    \n                  \n                  \n                    δ\n                    \n                      ℓ\n                    \n                  \n                  )\n                  \n                    \n                      \n                        d\n                        φ\n                        (\n                        \n                          \n                            net\n                          \n                          \n                            j\n                          \n                        \n                        )\n                      \n                      \n                        d\n                        \n                          \n                            net\n                          \n                          \n                            j\n                          \n                        \n                      \n                    \n                  \n                \n                \n                  \n                    if \n                  \n                  j\n                  \n                     is an inner neuron.\n                  \n                \n              \n            \n            \n          \n        \n      \n    \n    {\\displaystyle \\delta _{j}={\\frac {\\partial E}{\\partial o_{j}}}{\\frac {\\partial o_{j}}{\\partial {\\text{net}}_{j}}}={\\begin{cases}{\\frac {\\partial L(t,o_{j})}{\\partial o_{j}}}{\\frac {d\\varphi ({\\text{net}}_{j})}{d{\\text{net}}_{j}}}&{\\text{if }}j{\\text{ is an output neuron,}}\\\\(\\sum _{\\ell \\in L}w_{j\\ell }\\delta _{\\ell }){\\frac {d\\varphi ({\\text{net}}_{j})}{d{\\text{net}}_{j}}}&{\\text{if }}j{\\text{ is an inner neuron.}}\\end{cases}}}\n  \n\nif \n  \n    \n      \n        φ\n      \n    \n    {\\displaystyle \\varphi }\n  \n is the logistic function, and the error is the square error:\n\n  \n    \n      \n        \n          δ\n          \n            j\n          \n        \n        =\n        \n          \n            \n              ∂\n              E\n            \n            \n              ∂\n              \n                o\n                \n                  j\n                \n              \n            \n          \n        \n        \n          \n            \n              ∂\n              \n                o\n                \n                  j\n                \n              \n            \n            \n              ∂\n              \n                \n                  net\n                \n                \n                  j\n                \n              \n            \n          \n        \n        =\n        \n          \n            {\n            \n              \n                \n                  (\n                  \n                    o\n                    \n                      j\n                    \n                  \n                  −\n                  \n                    t\n                    \n                      j\n                    \n                  \n                  )\n                  \n                    o\n                    \n                      j\n                    \n                  \n                  (\n                  1\n                  −\n                  \n                    o\n                    \n                      j\n                    \n                  \n                  )\n                \n                \n                  \n                    if \n                  \n                  j\n                  \n                     is an output neuron,\n                  \n                \n              \n              \n                \n                  (\n                  \n                    ∑\n                    \n                      ℓ\n                      ∈\n                      L\n                    \n                  \n                  \n                    w\n                    \n                      j\n                      ℓ\n                    \n                  \n                  \n                    δ\n                    \n                      ℓ\n                    \n                  \n                  )\n                  \n                    o\n                    \n                      j\n                    \n                  \n                  (\n                  1\n                  −\n                  \n                    o\n                    \n                      j\n                    \n                  \n                  )\n                \n                \n                  \n                    if \n                  \n                  j\n                  \n                     is an inner neuron.\n                  \n                \n              \n            \n            \n          \n        \n      \n    \n    {\\displaystyle \\delta _{j}={\\frac {\\partial E}{\\partial o_{j}}}{\\frac {\\partial o_{j}}{\\partial {\\text{net}}_{j}}}={\\begin{cases}(o_{j}-t_{j})o_{j}(1-o_{j})&{\\text{if }}j{\\text{ is an output neuron,}}\\\\(\\sum _{\\ell \\in L}w_{j\\ell }\\delta _{\\ell })o_{j}(1-o_{j})&{\\text{if }}j{\\text{ is an inner neuron.}}\\end{cases}}}\n  \n\nTo update the weight \n  \n    \n      \n        \n          w\n          \n            i\n            j\n          \n        \n      \n    \n    {\\displaystyle w_{ij}}\n  \n using gradient descent, one must choose a learning rate, \n  \n    \n      \n        η\n        >\n        0\n      \n    \n    {\\displaystyle \\eta >0}\n  \n. The change in weight needs to reflect the impact on \n  \n    \n      \n        E\n      \n    \n    {\\displaystyle E}\n  \n of an increase or decrease in \n  \n    \n      \n        \n          w\n          \n            i\n            j\n          \n        \n      \n    \n    {\\displaystyle w_{ij}}\n  \n. If \n  \n    \n      \n        \n          \n            \n              ∂\n              E\n            \n            \n              ∂\n              \n                w\n                \n                  i\n                  j\n                \n              \n            \n          \n        \n        >\n        0\n      \n    \n    {\\displaystyle {\\frac {\\partial E}{\\partial w_{ij}}}>0}\n  \n, an increase in \n  \n    \n      \n        \n          w\n          \n            i\n            j\n          \n        \n      \n    \n    {\\displaystyle w_{ij}}\n  \n increases \n  \n    \n      \n        E\n      \n    \n    {\\displaystyle E}\n  \n; conversely, if \n  \n    \n      \n        \n          \n            \n              ∂\n              E\n            \n            \n              ∂\n              \n                w\n                \n                  i\n                  j\n                \n              \n            \n          \n        \n        <\n        0\n      \n    \n    {\\displaystyle {\\frac {\\partial E}{\\partial w_{ij}}}<0}\n  \n, an increase in \n  \n    \n      \n        \n          w\n          \n            i\n            j\n          \n        \n      \n    \n    {\\displaystyle w_{ij}}\n  \n decreases \n  \n    \n      \n        E\n      \n    \n    {\\displaystyle E}\n  \n. The new \n  \n    \n      \n        Δ\n        \n          w\n          \n            i\n            j\n          \n        \n      \n    \n    {\\displaystyle \\Delta w_{ij}}\n  \n is added to the old weight, and the product of the learning rate and the gradient, multiplied by \n  \n    \n      \n        −\n        1\n      \n    \n    {\\displaystyle -1}\n  \n guarantees that \n  \n    \n      \n        \n          w\n          \n            i\n            j\n          \n        \n      \n    \n    {\\displaystyle w_{ij}}\n  \n changes in a way that always decreases \n  \n    \n      \n        E\n      \n    \n    {\\displaystyle E}\n  \n. In other words, in the equation immediately below, \n  \n    \n      \n        −\n        η\n        \n          \n            \n              ∂\n              E\n            \n            \n              ∂\n              \n                w\n                \n                  i\n                  j\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle -\\eta {\\frac {\\partial E}{\\partial w_{ij}}}}\n  \n always changes \n  \n    \n      \n        \n          w\n          \n            i\n            j\n          \n        \n      \n    \n    {\\displaystyle w_{ij}}\n  \n in such a way that \n  \n    \n      \n        E\n      \n    \n    {\\displaystyle E}\n  \n is decreased:\n\n  \n    \n      \n        Δ\n        \n          w\n          \n            i\n            j\n          \n        \n        =\n        −\n        η\n        \n          \n            \n              ∂\n              E\n            \n            \n              ∂\n              \n                w\n                \n                  i\n                  j\n                \n              \n            \n          \n        \n        =\n        −\n        η\n        \n          o\n          \n            i\n          \n        \n        \n          δ\n          \n            j\n          \n        \n      \n    \n    {\\displaystyle \\Delta w_{ij}=-\\eta {\\frac {\\partial E}{\\partial w_{ij}}}=-\\eta o_{i}\\delta _{j}}\n  \n\n\n== Second-order gradient descent ==\n\nUsing a Hessian matrix of second-order derivatives of the error function, the Levenberg–Marquardt algorithm often converges faster than first-order gradient descent, especially when the topology of the error function is complicated. It may also find solutions in smaller node counts for which other methods might not converge. The Hessian can be approximated by the Fisher information matrix.\nAs an example, consider a simple feedforward network. At the \n  \n    \n      \n        l\n      \n    \n    {\\displaystyle l}\n  \n-th layer, we have\n  \n    \n      \n        \n          x\n          \n            i\n          \n          \n            (\n            l\n            )\n          \n        \n        ,\n        \n        \n          a\n          \n            i\n          \n          \n            (\n            l\n            )\n          \n        \n        =\n        f\n        (\n        \n          x\n          \n            i\n          \n          \n            (\n            l\n            )\n          \n        \n        )\n        ,\n        \n        \n          x\n          \n            i\n          \n          \n            (\n            l\n            +\n            1\n            )\n          \n        \n        =\n        \n          ∑\n          \n            j\n          \n        \n        \n          W\n          \n            i\n            j\n          \n        \n        \n          a\n          \n            j\n          \n          \n            (\n            l\n            )\n          \n        \n      \n    \n    {\\displaystyle x_{i}^{(l)},\\quad a_{i}^{(l)}=f(x_{i}^{(l)}),\\quad x_{i}^{(l+1)}=\\sum _{j}W_{ij}a_{j}^{(l)}}\n  \nwhere \n  \n    \n      \n        x\n      \n    \n    {\\displaystyle x}\n  \n are the pre-activations, \n  \n    \n      \n        a\n      \n    \n    {\\displaystyle a}\n  \n are the activations, and \n  \n    \n      \n        W\n      \n    \n    {\\displaystyle W}\n  \n is the weight matrix. Given a loss function \n  \n    \n      \n        L\n      \n    \n    {\\displaystyle L}\n  \n, the first-order backpropagation states that\n  \n    \n      \n        \n          \n            \n              ∂\n              L\n            \n            \n              ∂\n              \n                a\n                \n                  j\n                \n                \n                  (\n                  l\n                  )\n                \n              \n            \n          \n        \n        =\n        \n          ∑\n          \n            j\n          \n        \n        \n          W\n          \n            i\n            j\n          \n        \n        \n          \n            \n              ∂\n              L\n            \n            \n              ∂\n              \n                x\n                \n                  i\n                \n                \n                  (\n                  l\n                  +\n                  1\n                  )\n                \n              \n            \n          \n        \n        ,\n        \n        \n          \n            \n              ∂\n              L\n            \n            \n              ∂\n              \n                x\n                \n                  j\n                \n                \n                  (\n                  l\n                  )\n                \n              \n            \n          \n        \n        =\n        \n          f\n          ′\n        \n        (\n        \n          x\n          \n            j\n          \n          \n            (\n            l\n            )\n          \n        \n        )\n        \n          \n            \n              ∂\n              L\n            \n            \n              ∂\n              \n                a\n                \n                  j\n                \n                \n                  (\n                  l\n                  )\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\frac {\\partial L}{\\partial a_{j}^{(l)}}}=\\sum _{j}W_{ij}{\\frac {\\partial L}{\\partial x_{i}^{(l+1)}}},\\quad {\\frac {\\partial L}{\\partial x_{j}^{(l)}}}=f'(x_{j}^{(l)}){\\frac {\\partial L}{\\partial a_{j}^{(l)}}}}\n  \nand the second-order backpropagation states that\n  \n    \n      \n        \n          \n            \n              \n                ∂\n                \n                  2\n                \n              \n              L\n            \n            \n              ∂\n              \n                a\n                \n                  \n                    j\n                    \n                      1\n                    \n                  \n                \n                \n                  (\n                  l\n                  )\n                \n              \n              ∂\n              \n                a\n                \n                  \n                    j\n                    \n                      2\n                    \n                  \n                \n                \n                  (\n                  l\n                  )\n                \n              \n            \n          \n        \n        =\n        \n          ∑\n          \n            \n              j\n              \n                1\n              \n            \n            \n              j\n              \n                2\n              \n            \n          \n        \n        \n          W\n          \n            \n              i\n              \n                1\n              \n            \n            \n              j\n              \n                1\n              \n            \n          \n        \n        \n          W\n          \n            \n              i\n              \n                2\n              \n            \n            \n              j\n              \n                2\n              \n            \n          \n        \n        \n          \n            \n              \n                ∂\n                \n                  2\n                \n              \n              L\n            \n            \n              ∂\n              \n                x\n                \n                  \n                    i\n                    \n                      1\n                    \n                  \n                \n                \n                  (\n                  l\n                  +\n                  1\n                  )\n                \n              \n              ∂\n              \n                x\n                \n                  \n                    i\n                    \n                      2\n                    \n                  \n                \n                \n                  (\n                  l\n                  +\n                  1\n                  )\n                \n              \n            \n          \n        \n        ,\n        \n        \n          \n            \n              \n                ∂\n                \n                  2\n                \n              \n              L\n            \n            \n              ∂\n              \n                x\n                \n                  \n                    j\n                    \n                      1\n                    \n                  \n                \n                \n                  (\n                  l\n                  )\n                \n              \n              ∂\n              \n                x\n                \n                  \n                    j\n                    \n                      2\n                    \n                  \n                \n                \n                  (\n                  l\n                  )\n                \n              \n            \n          \n        \n        =\n        \n          f\n          ′\n        \n        (\n        \n          x\n          \n            \n              j\n              \n                1\n              \n            \n          \n          \n            (\n            l\n            )\n          \n        \n        )\n        \n          f\n          ′\n        \n        (\n        \n          x\n          \n            \n              j\n              \n                2\n              \n            \n          \n          \n            (\n            l\n            )\n          \n        \n        )\n        \n          \n            \n              \n                ∂\n                \n                  2\n                \n              \n              L\n            \n            \n              ∂\n              \n                a\n                \n                  \n                    j\n                    \n                      1\n                    \n                  \n                \n                \n                  (\n                  l\n                  )\n                \n              \n              ∂\n              \n                a\n                \n                  \n                    j\n                    \n                      2\n                    \n                  \n                \n                \n                  (\n                  l\n                  )\n                \n              \n            \n          \n        \n        +\n        \n          δ\n          \n            \n              j\n              \n                1\n              \n            \n            \n              j\n              \n                2\n              \n            \n          \n        \n        \n          f\n          ″\n        \n        (\n        \n          x\n          \n            \n              j\n              \n                1\n              \n            \n          \n          \n            (\n            l\n            )\n          \n        \n        )\n        \n          \n            \n              ∂\n              L\n            \n            \n              ∂\n              \n                a\n                \n                  \n                    j\n                    \n                      1\n                    \n                  \n                \n                \n                  (\n                  l\n                  )\n                \n              \n            \n          \n        \n      \n    \n    {\\displaystyle {\\frac {\\partial ^{2}L}{\\partial a_{j_{1}}^{(l)}\\partial a_{j_{2}}^{(l)}}}=\\sum _{j_{1}j_{2}}W_{i_{1}j_{1}}W_{i_{2}j_{2}}{\\frac {\\partial ^{2}L}{\\partial x_{i_{1}}^{(l+1)}\\partial x_{i_{2}}^{(l+1)}}},\\quad {\\frac {\\partial ^{2}L}{\\partial x_{j_{1}}^{(l)}\\partial x_{j_{2}}^{(l)}}}=f'(x_{j_{1}}^{(l)})f'(x_{j_{2}}^{(l)}){\\frac {\\partial ^{2}L}{\\partial a_{j_{1}}^{(l)}\\partial a_{j_{2}}^{(l)}}}+\\delta _{j_{1}j_{2}}f''(x_{j_{1}}^{(l)}){\\frac {\\partial L}{\\partial a_{j_{1}}^{(l)}}}}\n  \nwhere \n  \n    \n      \n        δ\n      \n    \n    {\\displaystyle \\delta }\n  \n is the Dirac delta symbol.\nArbitrary-order derivatives in arbitrary computational graphs can be computed with backpropagation, but with more complex expressions for higher orders.\n\n\n== Loss function ==\n\nThe loss function is a function that maps values of one or more variables onto a real number intuitively representing some \"cost\" associated with those values. For backpropagation, the loss function calculates the difference between the network output and its expected output, after a training example has propagated through the network.\n\n\n=== Assumptions ===\nThe mathematical expression of the loss function must fulfill two conditions in order for it to be possibly used in backpropagation. The first is that it can be written as an average \n  \n    \n      \n        E\n        =\n        \n          \n            1\n            n\n          \n        \n        \n          ∑\n          \n            x\n          \n        \n        \n          E\n          \n            x\n          \n        \n      \n    \n    {\\textstyle E={\\frac {1}{n}}\\sum _{x}E_{x}}\n  \n over error functions \n  \n    \n      \n        \n          E\n          \n            x\n          \n        \n      \n    \n    {\\textstyle E_{x}}\n  \n, for \n  \n    \n      \n        n\n      \n    \n    {\\textstyle n}\n  \n individual training examples, \n  \n    \n      \n        x\n      \n    \n    {\\textstyle x}\n  \n. The reason for this assumption is that the backpropagation algorithm calculates the gradient of the error function for a single training example, which needs to be generalized to the overall error function. The second assumption is that it can be written as a function of the outputs from the neural network.\n\n\n=== Example loss function ===\nLet \n  \n    \n      \n        y\n        ,\n        \n          y\n          ′\n        \n      \n    \n    {\\displaystyle y,y'}\n  \n be vectors in \n  \n    \n      \n        \n          \n            R\n          \n          \n            n\n          \n        \n      \n    \n    {\\displaystyle \\mathbb {R} ^{n}}\n  \n.\nSelect an error function \n  \n    \n      \n        E\n        (\n        y\n        ,\n        \n          y\n          ′\n        \n        )\n      \n    \n    {\\displaystyle E(y,y')}\n  \n measuring the difference between two outputs. The standard choice is the square of the Euclidean distance between the vectors \n  \n    \n      \n        y\n      \n    \n    {\\displaystyle y}\n  \n and \n  \n    \n      \n        \n          y\n          ′\n        \n      \n    \n    {\\displaystyle y'}\n  \n:\n  \n    \n      \n        E\n        (\n        y\n        ,\n        \n          y\n          ′\n        \n        )\n        =\n        \n          \n            \n              1\n              2\n            \n          \n        \n        ‖\n        y\n        −\n        \n          y\n          ′\n        \n        \n          ‖\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle E(y,y')={\\tfrac {1}{2}}\\lVert y-y'\\rVert ^{2}}\n  \nThe error function over \n  \n    \n      \n        n\n      \n    \n    {\\textstyle n}\n  \n training examples can then be written as an average of losses over individual examples:\n  \n    \n      \n        E\n        =\n        \n          \n            1\n            \n              2\n              n\n            \n          \n        \n        \n          ∑\n          \n            x\n          \n        \n        ‖\n        (\n        y\n        (\n        x\n        )\n        −\n        \n          y\n          ′\n        \n        (\n        x\n        )\n        )\n        \n          ‖\n          \n            2\n          \n        \n      \n    \n    {\\displaystyle E={\\frac {1}{2n}}\\sum _{x}\\lVert (y(x)-y'(x))\\rVert ^{2}}\n  \n\n\n== Limitations ==\n\nGradient descent with backpropagation is not guaranteed to find the global minimum of the error function, but only a local minimum; also, it has trouble crossing plateaus in the error function landscape. This issue, caused by the non-convexity of error functions in neural networks, was long thought to be a major drawback, but Yann LeCun et al. argue that in many practical problems, it is not.\nBackpropagation learning does not require normalization of input vectors; however, normalization could improve performance.\nBackpropagation requires the derivatives of activation functions to be known at network design time.\n\n\n== History ==\n\n\n=== Precursors ===\nBackpropagation had been derived repeatedly, as it is essentially an efficient application of the chain rule (first written down by Gottfried Wilhelm Leibniz in 1676) to neural networks.\nThe terminology \"back-propagating error correction\" was introduced in 1962 by Frank Rosenblatt, but he did not know how to implement this. In any case, he only studied neurons whose outputs were discrete levels, which only had zero derivatives, making backpropagation impossible.\nPrecursors to backpropagation appeared in optimal control theory since 1950s. Yann LeCun et al credits 1950s work by Pontryagin and others in optimal control theory, especially the adjoint state method, for being a continuous-time version of backpropagation. Hecht-Nielsen credits the Robbins–Monro algorithm (1951) and Arthur Bryson and Yu-Chi Ho's Applied Optimal Control (1969) as presages of backpropagation. Other precursors were Henry J. Kelley 1960, and Arthur E. Bryson (1961). In 1962, Stuart Dreyfus published a simpler derivation based only on the chain rule. In 1973, he adapted parameters of controllers in proportion to error gradients. Unlike modern backpropagation, these precursors used standard Jacobian matrix calculations from one stage to the previous one, neither addressing direct links across several stages nor potential additional efficiency gains due to network sparsity.\nThe ADALINE (1960) learning algorithm was gradient descent with a squared error loss for a single layer. The first multilayer perceptron (MLP) with more than one layer trained by stochastic gradient descent was published in 1967 by Shun'ichi Amari. The MLP had 5 layers, with 2 learnable layers, and it learned to classify patterns not linearly separable.\n\n\n=== Modern backpropagation ===\nModern backpropagation was first published by Seppo Linnainmaa as \"reverse mode of automatic differentiation\" (1970) for discrete connected networks of nested differentiable functions.\nIn 1982, Paul Werbos applied backpropagation to MLPs in the way that has become standard. Werbos described how he developed backpropagation in an interview. In 1971, during his PhD work, he developed backpropagation to mathematicize Freud's \"flow of psychic energy\". He faced repeated difficulty in publishing the work, only managing in 1981. He also claimed that \"the first practical application of back-propagation was for estimating a dynamic model to predict nationalism and social communications in 1974\" by him.\nAround 1982, David E. Rumelhart independently developed backpropagation and taught the algorithm to others in his research circle. He did not cite previous work as he was unaware of them. He published the algorithm first in a 1985 paper, then in a 1986 Nature paper an experimental analysis of the technique. These papers became highly cited, contributed to the popularization of backpropagation, and coincided with the resurging research interest in neural networks during the 1980s.\nIn 1985, the method was also described by David Parker. Yann LeCun proposed an alternative form of backpropagation for neural networks in his PhD thesis in 1987.\nGradient descent took a considerable amount of time to reach acceptance. Some early objections were: there were no guarantees that gradient descent could reach a global minimum, only local minimum; neurons were \"known\" by physiologists as making discrete signals (0/1), not continuous ones, and with discrete signals, there is no gradient to take. See the interview with Geoffrey Hinton, who was awarded the 2024 Nobel Prize in Physics for his contributions to the field.\n\n\n=== Early successes ===\nContributing to the acceptance were several applications in training neural networks via backpropagation, sometimes achieving popularity outside the research circles.\nIn 1987, NETtalk learned to convert English text into pronunciation. Sejnowski tried training it with both backpropagation and Boltzmann machine, but found the backpropagation significantly faster, so he used it for the final NETtalk. The NETtalk program became a popular success, appearing on the Today show.\nIn 1989, Dean A. Pomerleau published ALVINN, a neural network trained to drive autonomously using backpropagation.\nThe LeNet was published in 1989 to recognize handwritten zip codes.\nIn 1992, TD-Gammon achieved top human level play in backgammon. It was a reinforcement learning agent with a neural network with two layers, trained by backpropagation.\nIn 1993, Eric Wan won an international pattern recognition contest through backpropagation.\n\n\n=== After backpropagation ===\nDuring the 2000s it fell out of favour, but returned in the 2010s, benefiting from cheap, powerful GPU-based computing systems. This has been especially so in speech recognition, machine vision, natural language processing, and language structure learning research (in which it has been used to explain a variety of phenomena related to first and second language learning.)\nError backpropagation has been suggested to explain human brain event-related potential (ERP) components like the N400 and P600.\nIn 2023, a backpropagation algorithm was implemented on a photonic processor by a team at Stanford University.\n\n\n== See also ==\nArtificial neural network\nNeural circuit\nCatastrophic interference\nEnsemble learning\nAdaBoost\nOverfitting\nNeural backpropagation\nBackpropagation through time\nBackpropagation through structure\nThree-factor learning\n\n\n== Notes ==\n\n\n== References ==\n\n\n== Further reading ==\nGoodfellow, Ian; Bengio, Yoshua; Courville, Aaron (2016). \"6.5 Back-Propagation and Other Differentiation Algorithms\". Deep Learning. MIT Press. pp. 200–220. ISBN 978-0-262-03561-3.\nNielsen, Michael A. (2015). \"How the backpropagation algorithm works\". Neural Networks and Deep Learning. Determination Press.\nMcCaffrey, James (October 2012). \"Neural Network Back-Propagation for Programmers\". MSDN Magazine.\nRojas, Raúl (1996). \"The Backpropagation Algorithm\" (PDF). Neural Networks: A Systematic Introduction. Berlin: Springer. ISBN 3-540-60505-3.\n\n\n== External links ==\nBackpropagation neural network tutorial at the Wikiversity\nBernacki, Mariusz; Włodarczyk, Przemysław (2004). \"Principles of training multi-layer neural network using backpropagation\".\nKarpathy, Andrej (2016). \"Lecture 4: Backpropagation, Neural Networks 1\". CS231n. Stanford University. Archived from the original on 2021-12-12 – via YouTube.\n\"What is Backpropagation Really Doing?\". 3Blue1Brown. November 3, 2017. Archived from the original on 2021-12-12 – via YouTube.\nPutta, Sudeep Raja (2022). \"Yet Another Derivation of Backpropagation in Matrix Form\"."
}